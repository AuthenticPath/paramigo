--- README.md ---
# Paramigo Project Summary & State

**Date:** June 23, 2025
**Project ID:** `paramigo-tool-03`
**Status:** The core application and the final quiz feature are fully functional. The primary learning loop (Library -> Lesson -> Quiz -> Results -> Smart Focus) is complete, and a cumulative testing mechanism with history is now in place. The application is robust and ready for production preparation or new feature development.

## 1. Project Overview

**Paramigo** is a personalized, adaptive learning tool designed to train new financial advisors. It transforms a library of existing training content (from Google Docs) into an interactive, persistent learning experience.

The core user experience is a web application where an advisor can:

1.  Log in securely with their Google account.
2.  Choose a learning style during a one-time onboarding, which can be changed later.
3.  Browse a library of training topics and a history of past final quizzes.
4.  Select a topic to view its history or start a new lesson attempt.
5.  Take an AI-generated lesson tailored to their learning style.
6.  Complete a quiz and review their score, question-by-question explanations, and the original lesson content.
7.  If they struggled on a lesson, they are offered a "Smart Focus" opportunity to generate a new, consolidated lesson covering their weak points.
8.  Create, take, and review **Final Cumulative Quizzes** that test knowledge across multiple topics. These final quizzes also have their own persistent history and can be retaken.
9.  All lesson attempts (regular, focused, and final) are saved to the user's history.
10. An "Ask Tutor" feature is available for specific questions during lessons and reviews.

## 2. Architecture

The application uses a client-server architecture with a clear separation of concerns:

- **Frontend (Client-Side):** A single-page application (SPA) experience built with vanilla HTML, CSS, and modern JavaScript (`type="module"`). It manages all UI views dynamically without full page reloads. It is served by the Flask backend but handles all Firebase Authentication on the client side.
- **Backend (Server-Side):** A Python application built with the **Flask** web framework, acting as an API server. It provides data endpoints that the frontend calls to get information or trigger actions. Key responsibilities include:
  - Serving the main `index.html` shell and `onboarding.html` page.
  - Providing API endpoints like `/get_library_and_history`, `/submit_quiz`, `/generate_final_quiz`, and `/submit_final_quiz`.
  - Communicating securely with Google Cloud services (Firestore and Google AI).
- **Database:** **Google Cloud Firestore** in Native Mode acts as our primary database. It is structured into collections:
  - `ContentMaster`: Stores the structured, parsed content from all Google Docs lessons. This is our single source of truth for all training material.
  - `Users`: Stores a profile for each authenticated user, keyed by their Firebase UID. Each user document contains two subcollections:
    - `lesson_attempts`: Stores a permanent record of every single-topic lesson they take (regular and Smart Focus).
    - `final_quiz_attempts`: Stores a permanent record of every cumulative final quiz they take.

## 3. Tech Stack

- **Backend Language:** Python 3
- **Web Framework:** Flask
- **Frontend Languages:** HTML5, CSS3, JavaScript (ESM)
- **Database:** Google Cloud Firestore (NoSQL)
- **Authentication:** Firebase Authentication
- **AI / Generative Models:** Google AI Platform (Gemini 1.5 Flash via `google-generativeai`)
- **Cloud Platform:** Google Cloud Platform (GCP) & Firebase
- **Key Python Libraries:** `flask`, `google-cloud-firestore`, `google-generativeai`, `python-dotenv`
- **Key Frontend Libraries:** `firebase-app.js`, `firebase-auth.js` (v10 Modular SDK)

## 4. Features Implemented So Far

- **Automated Content Pipeline:** A `parser.py` script connects to Google Drive, parses linked Google Docs, and uploads structured content to the `ContentMaster` collection in Firestore.
- **User Authentication & Onboarding:** Robust "Sign in with Google" via Firebase. New users are directed to a one-time onboarding page to select a learning style.
- **Structured Learning Flow:** The main page shows a library of all topics. Clicking a topic opens a "detail" view showing its specific history and an option to start a new attempt.
- **Intelligent "Smart Focus" Generation:** After a regular quiz, the system identifies missed concepts and uses the AI to generate a holistic summary and a button to create a new, consolidated lesson on those weak points.
- **Quiz and History Management:**
  - **Retake Quiz:** Users can retake any regular or final quiz. This creates a new attempt using the exact same questions as the original but shuffles the question order.
  - **Delete Attempt:** Users can permanently delete any past _regular lesson_ attempt from their history.
- **AI Tutor:** A floating chat window allows users to ask questions about the current lesson content.
- **Final Cumulative Quizzes (Stateful):**
  - **Topic Selection:** A modal allows users to select multiple topics for a cumulative quiz, with a "Select All / Deselect All" option for convenience.
  - **AI Generation:** A dedicated backend endpoint (`/generate_final_quiz`) fetches content for all selected topics and uses the AI to generate a unique, consolidated quiz.
  - **Persistent History:** Each final quiz attempt is saved to a dedicated `final_quiz_attempts` collection in Firestore, appearing in a "Final Quiz History" section on the main library page.
  - **Review & Retake:** Users can review past final quiz results and retake any final quiz, just like a regular lesson.

## 5. Outstanding Tasks or Next Steps

The core application is functionally complete and refined. The logical next steps would focus on production readiness or adding major new features.

- **Production Deployment:** Configure the application to run on a production-grade WSGI server (like Gunicorn) and host it on a service like Google App Engine or Cloud Run.
- **UI/UX Refinement:** Further polish the CSS, improve loading states, and potentially add more engaging animations or transitions between views.
- **Enhanced User Dashboard:** The "Topic Detail" view could be expanded into a full dashboard showing metrics like overall score average, most challenging topics, and progress over time.
- **Content Versioning:** Implement a feature where users are notified if a lesson they completed has been updated in the `ContentMaster` library.

## 6. Important Design Decisions

- **Stateful Backend / Generate-and-Store Model:** We deliberately chose to store every lesson attempt and final quiz in the database. This enables a rich, persistent user history at the cost of increased database storage.
- **Client-Side View Management:** The frontend acts as a Single-Page Application (SPA), providing a faster, more fluid user experience.
- **Integrated History:** We decided to associate "Smart Focus" lessons with the parent topic's ID to keep the history organized. Final quizzes have their own separate history list on the main page.
- **Frontend Resilience (The Radio Button Fix):** We implemented a `normalizeOptions()` helper function in the frontend JavaScript. This function defensively checks if the quiz options received from the AI are a string instead of an array, and if so, it intelligently parses the string into a proper array. This makes the UI resilient to malformed AI responses and prevents rendering bugs.
- **Stateful Final Quizzes:** We made a key decision to make the Final Quiz feature stateful, giving it its own history, review, and retake capabilities, which mirrors the functionality of regular lessons and makes the feature much more useful.

## 7. Assumptions or Constraints

- **Assumption:** The source Google Docs will maintain a consistent structure that the `parser.py` script can rely on.
- **Constraint:** The application is currently configured for local development and has not been hardened or optimized for a production environment.
- **Constraint:** The AI model (Gemini 1.5 Flash) is fast and cost-effective but may occasionally produce malformed JSON. Our `normalizeOptions()` frontend function and `_normalise_ai_json()` backend function are designed to mitigate these issues.

## 8. Naming Conventions and Folder Structure

The project is organized in a standard Flask structure:

```
paramigo/
├── static/
│   └── style.css         # All CSS styles
├── templates/
│   ├── index.html        # The single HTML shell for the entire app
│   └── onboarding.html   # The learning style selection page
├── .env                  # Stores secret keys (e.g., GOOGLE_API_KEY)
├── app.py                # Main Flask web server and all API endpoints
└── ...                   (other files like parser.py, client_secret.json, etc.)
```

- **API Routes:** Backend routes are prefixed with `/` and follow a clear verb-noun structure (e.g., `/get_library_and_history`, `/generate_final_quiz`).
- **CSS/JS:** All CSS is in `static/style.css`. All JavaScript is contained within a single `<script type="module">` block in `index.html`.

## 9. Anything Else Important to Carry Forward

The most critical lesson learned during development has been the need for a resilient frontend that does not blindly trust the structure of API responses, especially from a generative AI.

- The implementation of the `normalizeOptions()` function is a prime example of this lesson and a pattern we should remember. It defensively checks and cleans incoming data at the point of rendering, preventing UI bugs.
- Debugging by printing the raw AI response in the backend terminal remains the most effective strategy for solving generation issues.

## 10. My preferred working style and rules to remember about how I like to work together

- **DO NOT LIE. DO NOT OMIT CODE.** This is the most important rule. You must provide the complete, top-to-bottom code for every file you are asked to produce. Do not use placeholders, summaries, or comments like "Omitted for brevity." This is a critical matter of trust and functionality.
- **Be Honest About Mistakes:** If I ask if you omitted something, be truthful. It is better to admit a mistake and fix it than to deny it.
- **Structure and Clarity:** I prefer a step-by-step, methodical approach. The "Plan -> Action -> What to Do Next" format works well.
- **Complete Files:** When providing code, always provide the entire file content, not just the changed snippets. This prevents copy-paste errors and ensures we are always working from a complete and correct baseline.
- **Acknowledge the User's Frustration:** When a bug is persistent or a mistake is repeated, it's important to acknowledge the user's frustration and the severity of the issue before moving on to the solution.


--- app.py ---
# FILE: app.py

import os, json, re, io
from flask import Flask, render_template, jsonify, request, send_file
from google.cloud import firestore
from dotenv import load_dotenv
import google.generativeai as genai
from openpyxl import Workbook
from fpdf import FPDF


# ── CONFIG ───────────────────────────────────────────────────────────────────────
load_dotenv()
genai.configure(api_key=os.environ["GOOGLE_API_KEY"])
db  = firestore.Client()
app = Flask(__name__)

# ── HELPERS ──────────────────────────────────────────────────────────────────────
_FENCE_RE = re.compile(r"```(?:json)?|```", re.I)
def _strip_fences(text: str) -> str: return _FENCE_RE.sub("", text).strip()
def _normalise_ai_json(obj: dict) -> dict:
    questions = obj.get("quiz_questions") or obj.get("quizQuestions") or []
    if not isinstance(questions, list):
        questions = []
    return {"lesson_html": obj.get("lesson_html") or obj.get("lessonHtml") or "","quiz_questions": questions}

# ── PAGES ────────────────────────────────────────────────────────────────────────
@app.route("/")
def home(): return render_template("index.html")

@app.route("/onboarding")
def onboarding():
    styles = [
        {"style_name": "The Mentor", "explanation": "Imagine you have a friendly, experienced guide. This style uses analogies and stories to explain concepts, focusing on the 'why' behind the advice. It's encouraging and patient."},
        {"style_name": "The Analyst", "explanation": "This style is for the data-driven learner. It presents information with a focus on numbers, charts, and logical steps. It's precise, structured, and prioritizes factual accuracy."},
        {"style_name": "The Conversationalist", "explanation": "This style delivers lessons in the form of a dialogue between a learner and a teacher. It's relaxed, question-driven, and conversational — like a podcast or coaching session. Great for people who learn best by hearing both sides of an idea."}
    ]
    return render_template("onboarding.html", styles=styles)

# ── API: DATA LOADING ────────────────────────────────────────────────────────────
# THIS IS THE REPLACEMENT FOR THE ENTIRE get_library_and_history FUNCTION

@app.route("/get_library_and_history", methods=["POST"])
def get_library_and_history():
    data = request.get_json()
    user_id = data.get("user_id")
    if not user_id: return jsonify({"error": "User ID is required."}), 400

    # --- NEW: Fetch user profile data at the same time ---
    user_profile = {}
    try:
        user_ref = db.collection("Users").document(user_id)
        user_doc = user_ref.get()
        if user_doc.exists:
            user_profile = user_doc.to_dict()
    except Exception as e:
        print(f"[get_library_and_history] Could not fetch user profile: {e}")
    # --- END NEW ---

    # Fetch lesson attempt history
    lesson_history_docs = db.collection("Users").document(user_id).collection("lesson_attempts").order_by("started_at", direction=firestore.Query.DESCENDING).stream()
    history_by_lesson = {}
    for doc in lesson_history_docs:
        d = doc.to_dict()
        lesson_id = d.get("lesson_id")
        if lesson_id not in history_by_lesson:
            history_by_lesson[lesson_id] = []
        history_by_lesson[lesson_id].append({"attempt_id": doc.id, "title": d.get("title"), "score": d.get("score"), "questions_total": d.get("questions_total"), "started_at": d.get("started_at").isoformat()})

    # Fetch the main library content and separate it
    library_docs = db.collection("ContentMaster").stream()
    official_library = []
    user_creations = []
    for doc in library_docs:
        doc_dict = doc.to_dict()
        title = doc_dict.get("title")
        if title:
            lesson_id = doc.id
            lesson_data = {"id": lesson_id, "title": title, "attempts": history_by_lesson.get(lesson_id, [])}
            if doc_dict.get("ai_generated"):
                user_creations.append(lesson_data)
            else:
                official_library.append(lesson_data)

    # Fetch final quiz history
    final_quiz_history = []
    final_quiz_docs = db.collection("Users").document(user_id).collection("final_quiz_attempts").order_by("started_at", direction=firestore.Query.DESCENDING).stream()
    for doc in final_quiz_docs:
        d = doc.to_dict()
        final_quiz_history.append({
            "attempt_id": doc.id,
            "title": d.get("title"),
            "score": d.get("score"),
            "questions_total": d.get("questions_total"),
            "started_at": d.get("started_at").isoformat()
        })
        
    # --- NEW: Return the user's learning style along with everything else ---
    return jsonify({
        "library": official_library,
        "user_creations": user_creations,
        "final_quiz_history": final_quiz_history,
        "learningStyle": user_profile.get("learningStyle", "Not Set") # Add this line
    })

@app.route("/get_lesson_attempt", methods=["POST"])
def get_lesson_attempt():
    data = request.get_json()
    user_id, attempt_id = data.get("user_id"), data.get("attempt_id")
    try:
        attempt_ref = db.collection("Users").document(user_id).collection("lesson_attempts").document(attempt_id)
        attempt_doc = attempt_ref.get()
        if not attempt_doc.exists: return jsonify({"error": "Attempt not found."}), 404
        d = attempt_doc.to_dict()
        
        default_focus = {"smart_focus_needed": False, "missed_concepts": [], "explanation": ""}
        smart_focus_data = d.get("smart_focus", default_focus)

        results_package = {
            "lesson_id": d.get("lesson_id"),
            "content": d.get("lesson_content"),
            "user_answers": d.get("user_answers"),
            "score": d.get("score"),
            "questions_total": d.get("questions_total"),
            "smart_focus": smart_focus_data
        }
        return jsonify(results_package)
    except Exception as e:
        print(f"[get_lesson_attempt] Firestore error: {e}")
        return jsonify({"error": "Could not retrieve lesson history."}), 500

@app.route("/get_source_material", methods=["POST"])
def get_source_material():
    data = request.get_json()
    lesson_id = data.get("lesson_id")
    if not lesson_id: return jsonify({"error": "Lesson ID is required."}), 400
    try:
        doc_ref = db.collection("ContentMaster").document(lesson_id)
        doc = doc_ref.get()
        if not doc.exists: return jsonify({"error": "Source material not found"}), 404
        return jsonify(doc.to_dict())
    except Exception as e:
        print(f"[get_source_material] Firestore error: {e}")
        return jsonify({"error": "Could not retrieve source material."}), 500
    

# ==== [1] GET USER PROFILE (This is the new function to add) ====
@app.route("/get_user_profile", methods=["POST"])
def get_user_profile():
    data = request.get_json()
    user_id = data.get("user_id")
    if not user_id: 
        return jsonify({"error": "User ID is required."}), 400
    try:
        user_ref = db.collection("Users").document(user_id)
        user_doc = user_ref.get()
        if user_doc.exists:
            # We return the entire user document, which includes the 'learningStyle' key
            return jsonify(user_doc.to_dict())
        else:
            return jsonify({"error": "User not found"}), 404
    except Exception as e:
        print(f"[get_user_profile] Firestore error: {e}")
        return jsonify({"error": "Could not retrieve user profile."}), 500

# ── USER/PROFILE API ─────────────────────────────────────────────────────────────
@app.route("/create_user", methods=["POST"])
def create_user():
    data = request.get_json()
    uid = data.get("uid")
    if not uid: return jsonify({"status": "error", "message": "User ID required."}), 400
    doc_ref = db.collection("Users").document(uid)
    if not doc_ref.get().exists:
        doc_ref.set({"displayName" : data.get("displayName"),"email" : data.get("email"),"created_at"  : firestore.SERVER_TIMESTAMP,"learningStyle": None})
        return jsonify({"status": "success", "is_new_user": True, "needs_onboarding": True})
    user_data = doc_ref.get().to_dict()
    needs_onboarding = "learningStyle" not in user_data or user_data.get("learningStyle") is None
    return jsonify({"status": "success", "is_new_user": False, "needs_onboarding": needs_onboarding})

@app.route("/save_preference", methods=["POST"])
def save_preference():
    data = request.get_json()
    uid, style = data.get("uid"), data.get("style")
    if not uid or not style: return jsonify({"status": "error", "message": "UID and style are required."}), 400
    try:
        db.collection("Users").document(uid).update({"learningStyle": style})
        return jsonify({"status": "success"})
    except Exception as e:
        print(f"[save_preference] Firestore error: {e}")
        return jsonify({"status": "error", "message": "Could not save preference."}), 500

@app.route("/start_lesson", methods=["POST"])
def start_lesson():
    data = request.get_json()
    user_id, lesson_id = data.get("user_id"), data.get("lesson_id")
    original_attempt_id = data.get("original_attempt_id")

    try:
        user_doc = db.collection("Users").document(user_id).get()
        learning_style = user_doc.to_dict().get("learningStyle") or "The Mentor"
    except Exception: learning_style = "The Mentor"

    lesson_content = None
    source_title = ""

    if original_attempt_id:
        original_attempt_doc = db.collection("Users").document(user_id).collection("lesson_attempts").document(original_attempt_id).get()
        if original_attempt_doc.exists:
            lesson_content = original_attempt_doc.to_dict().get("lesson_content")
            source_title = original_attempt_doc.to_dict().get("title")
        else:
            return jsonify({"error": "Original attempt not found for retake."}), 404
    else:
        source_doc_ref = db.collection("ContentMaster").document(lesson_id)
        source_doc = source_doc_ref.get()
        if not source_doc.exists: return jsonify({"error": "Lesson not found."}), 404
        
        source_content_full = source_doc.to_dict()
        source_title = source_content_full.get("title")

        def datetime_converter(o):
            if isinstance(o, firestore.firestore.DatetimeWithNanoseconds):
                return o.isoformat()
            raise TypeError(f"Object of type {o.__class__.__name__} is not JSON serializable")

        # --- THIS IS THE FIX ---
        # If the topic is AI-generated, the "source" for the new AI prompt
        # is the content inside the 'lesson_content' field.
        if source_content_full.get("ai_generated"):
            source_for_prompt = source_content_full.get("lesson_content", {})
            prompt = f'You are an expert educator and trainer. Teach in the "{learning_style}" voice using the content provided as your source material. **OUTPUT REQUIREMENTS (pure JSON):** {{"lesson_html": "<string - raw HTML>", "quiz_questions": [{{ "question": "<string>", "options": ["A", "B", "C", "D"], "correct_answer_index": 0, "explanation": "<string>" }}]}} # SOURCE MATERIAL: {json.dumps(source_for_prompt, default=datetime_converter, ensure_ascii=False)}'
        else:
            # For human-made topics, the entire document is the source.
            source_for_prompt = source_content_full
            prompt = f'You are an expert financial trainer. Teach in the "{learning_style}" voice. **OUTPUT REQUIREMENTS (pure JSON):** {{"lesson_html": "<string - raw HTML>", "quiz_questions": [{{ "question": "<string>", "options": ["A", "B", "C", "D"], "correct_answer_index": 0, "explanation": "<string>" }}]}} # SOURCE MATERIAL: {json.dumps(source_for_prompt, default=datetime_converter, ensure_ascii=False)}'
        
        try:
            model = genai.GenerativeModel("gemini-1.5-flash")
            raw_json = model.generate_content(prompt).text
            lesson_content = _normalise_ai_json(json.loads(_strip_fences(raw_json)))
        except Exception as e:
            print(f"[start_lesson] AI or JSON error: {e}")
            return jsonify({"error": "Lesson generation failed."}), 500

    if not lesson_content: return jsonify({"error": "Failed to get or generate lesson content."}), 500

    try:
        attempt_ref = db.collection("Users").document(user_id).collection("lesson_attempts").document()
        attempt_ref.set({ "lesson_id": lesson_id, "title": source_title, "learning_style": learning_style, "started_at": firestore.SERVER_TIMESTAMP, "status": "in-progress", "lesson_content": lesson_content, "user_answers": {}, "score": None, "questions_total": len(lesson_content.get("quiz_questions", [])) })
        return jsonify({"attempt_id": attempt_ref.id, "content": lesson_content, "lesson_id": lesson_id})
    except Exception as e:
        print(f"[start_lesson] Firestore error: {e}")
        return jsonify({"error": "Could not save new lesson attempt."}), 500

@app.route("/submit_quiz", methods=["POST"])
def submit_quiz():
    data = request.get_json()
    user_id, attempt_id, user_answers, lesson_id = data.get("user_id"), data.get("attempt_id"), data.get("user_answers"), data.get("lesson_id")
    attempt_ref = db.collection("Users").document(user_id).collection("lesson_attempts").document(attempt_id)
    attempt_doc = attempt_ref.get()
    if not attempt_doc.exists: return jsonify({"error": "Lesson attempt not found."}), 404
    
    lesson_content = attempt_doc.to_dict().get("lesson_content", {})
    quiz_questions = lesson_content.get("quiz_questions", [])
    
    score = 0
    missed_concepts = []
    for i, q in enumerate(quiz_questions):
        user_answer_index = user_answers.get(str(i))
        correct_answer_index = q.get("correct_answer_index")
        if user_answer_index is not None and int(user_answer_index) == correct_answer_index:
            score += 1
        else:
            missed_concepts.append(q.get("question"))

    smart_focus_data = {'smart_focus_needed': False, 'missed_concepts': [], 'explanation': ''}
    if missed_concepts:
        learning_style = attempt_doc.to_dict().get("learning_style", "The Mentor")
        sf_prompt = f'A user has completed a quiz and struggled with the concepts underlying the following questions: {json.dumps(missed_concepts)} Your task is to provide a single, cohesive "quick refresher" summary (as plain text, <200 words). This summary should explain the foundational principles or themes that connect these missed concepts. The user\'s learning style is "{learning_style}". Return ONLY the plain text explanation, no markdown.'

        try:
            model = genai.GenerativeModel('gemini-1.5-flash')
            explanation = model.generate_content(sf_prompt).text.strip()
            smart_focus_data = {
                'smart_focus_needed': True,
                'missed_concepts': missed_concepts,
                'explanation': explanation
            }
        except Exception as e:
            print(f"[smart_focus] AI error: {e}")

    attempt_ref.update({ "status": "completed", "user_answers": user_answers, "score": score, "completed_at": firestore.SERVER_TIMESTAMP, "smart_focus": smart_focus_data })
    
    return jsonify({"lesson_id": lesson_id, "content": lesson_content, "user_answers": user_answers, "score": score, "questions_total": len(quiz_questions), "smart_focus": smart_focus_data})

@app.route("/start_multi_concept_lesson", methods=["POST"])
def start_multi_concept_lesson():
    data = request.get_json()
    user_id, concepts, parent_lesson_id = data.get("user_id"), data.get("concepts"), data.get("parent_lesson_id")
    if not all([user_id, concepts, parent_lesson_id]):
        return jsonify({"error": "User ID, a list of concepts, and parent lesson ID are required."}), 400

    try:
        user_doc = db.collection("Users").document(user_id).get()
        learning_style = user_doc.to_dict().get("learningStyle") or "The Mentor"
    except Exception: learning_style = "The Mentor"
    
    title = f"Focused Lesson on Key Concepts"
    prompt = f"""
    You are an expert financial trainer. Your task is to create a single, cohesive, foundational micro-lesson that addresses all the concepts a user struggled with.
    The user's learning style is "{learning_style}".
    The user struggled with the concepts underlying these questions:
    {json.dumps(concepts)}

    Instead of teaching to each question one-by-one, synthesize the underlying principles into a single lesson. Teach the "why" behind these concepts to build a stronger foundation.

    **OUTPUT REQUIREMENTS (pure JSON):**
    {{
      "lesson_html": "<string - A detailed HTML explanation of the foundational concepts, as if it were a full lesson. Use tags like <h2>, <p>, <ul> etc.>",
      "quiz_questions": [
        {{ "question": "<A question that tests the synthesized foundational knowledge>", "options": ["A", "B", "C", "D"], "correct_answer_index": 0, "explanation": "<Detailed explanation for this specific question>" }},
        {{ "question": "<A second, different question testing the core principles>", "options": ["A", "B", "C", "D"], "correct_answer_index": 1, "explanation": "<Detailed explanation for this specific question>" }}
      ]
    }}
    """
    
    try:
        model = genai.GenerativeModel("gemini-1.5-flash")
        raw_json = model.generate_content(prompt).text
        lesson_content = _normalise_ai_json(json.loads(_strip_fences(raw_json)))
    except Exception as e:
        print(f"[start_multi_concept_lesson] AI or JSON error: {e}")
        return jsonify({"error": "Focused lesson generation failed."}), 500

    try:
        attempt_ref = db.collection("Users").document(user_id).collection("lesson_attempts").document()
        attempt_ref.set({
            "lesson_id": parent_lesson_id, 
            "title": title, 
            "learning_style": learning_style,
            "started_at": firestore.SERVER_TIMESTAMP, 
            "status": "in-progress",
            "lesson_content": lesson_content, 
            "user_answers": {}, 
            "score": None,
            "questions_total": len(lesson_content.get("quiz_questions", []))
        })
        return jsonify({"attempt_id": attempt_ref.id, "content": lesson_content, "lesson_id": parent_lesson_id})
    except Exception as e:
        print(f"[start_multi_concept_lesson] Firestore error: {e}")
        return jsonify({"error": "Could not save focused lesson."}), 500

@app.route("/delete_attempt", methods=["POST"])
def delete_attempt():
    data = request.get_json()
    user_id, attempt_id = data.get("user_id"), data.get("attempt_id")
    if not user_id or not attempt_id: return jsonify({"status": "error", "message": "User and attempt ID are required."}), 400
    try:
        db.collection("Users").document(user_id).collection("lesson_attempts").document(attempt_id).delete()
        return jsonify({"status": "success"})
    except Exception as e:
        print(f"[delete_attempt] Firestore error: {e}")
        return jsonify({"status": "error", "message": "Could not delete attempt."}), 500

@app.route("/ask_tutor", methods=["POST"])
def ask_tutor():
    data = request.get_json()
    question, context = data.get("question"), data.get("context")
    if not question or not context: return jsonify({"error": "A question and lesson context are required."}), 400
    prompt = f"You are a helpful AI Tutor for financial advisors. Answer the user's question based *only* on the provided lesson context. If the question cannot be answered from the context, politely state that you can only answer questions directly related to the current lesson material.\n\n# LESSON CONTEXT:\n{context}\n\n# USER'S QUESTION:\n{question}"
    try:
        model = genai.GenerativeModel("gemini-1.5-flash")
        answer = model.generate_content(prompt).text.strip()
        return jsonify({"answer": answer})
    except Exception as e:
        print(f"[ask_tutor] AI generation error: {e}")
        return jsonify({"error": "Sorry, I had a problem generating an answer."}), 500
    
@app.route("/delete_custom_topic", methods=["POST"])
def delete_custom_topic():
    data = request.get_json()
    user_id, topic_id = data.get("user_id"), data.get("topic_id")
    if not all([user_id, topic_id]): 
        return jsonify({"error": "User ID and Topic ID are required."}), 400

    try:
        # Use a transaction or a batch to ensure atomicity
        batch = db.batch()

        # 1. Delete the master document from ContentMaster
        master_ref = db.collection("ContentMaster").document(topic_id)
        batch.delete(master_ref)

        # 2. Find and delete all lesson attempts associated with this topic for the user
        attempts_query = db.collection("Users").document(user_id).collection("lesson_attempts").where("lesson_id", "==", topic_id)
        for doc in attempts_query.stream():
            batch.delete(doc.reference)
        
        # 3. Commit all the deletions at once
        batch.commit()
        
        return jsonify({"status": "success", "message": f"Topic {topic_id} and all its attempts have been deleted."})
    except Exception as e:
        print(f"[delete_custom_topic] Error: {e}")
        return jsonify({"error": "Failed to delete the custom topic and its history."}), 500


# ── API: DYNAMIC CONTENT & TOOLS ───────────────────────────────────────────────
@app.route("/create_custom_topic", methods=["POST"])
def create_custom_topic():
    data = request.get_json()
    user_id, topic_title = data.get("user_id"), data.get("topic_title")
    if not all([user_id, topic_title]): return jsonify({"error": "User ID and topic title are required."}), 400
    
    try:
        user_doc = db.collection("Users").document(user_id).get()
        learning_style = user_doc.to_dict().get("learningStyle") or "The Mentor"
    except Exception: learning_style = "The Mentor"

    prompt = f'You are an expert educator and trainer. Create a complete lesson about "{topic_title}". The lesson should be comprehensive and well-structured. Teach in the "{learning_style}" voice. **OUTPUT REQUIREMENTS (pure JSON):** {{"lesson_html": "<string - raw HTML>", "quiz_questions": [{{ "question": "<string>", "options": ["A", "B", "C", "D"], "correct_answer_index": 0, "explanation": "<string>" }}]}}'
    
    try:
        model = genai.GenerativeModel("gemini-1.5-flash")
        response = model.generate_content(prompt)
        raw_text = _strip_fences(response.text)
        
        try:
            lesson_content = _normalise_ai_json(json.loads(raw_text))
        except json.JSONDecodeError:
            print(f"[create_custom_topic] FAILED TO PARSE AI RESPONSE. AI likely returned an error page or non-JSON text.")
            print(f"RAW AI RESPONSE WAS: {raw_text}")
            return jsonify({"error": "The AI was unable to generate this topic, possibly due to safety filters or an internal error. Please try a different topic."}), 500

    except Exception as e:
        print(f"[create_custom_topic] AI generation error: {e}")
        return jsonify({"error": "An unexpected error occurred while generating the topic."}), 500
        
    if not lesson_content.get("lesson_html"): return jsonify({"error": "AI failed to generate lesson content."}), 500

    try:
        # Use a batch to perform both writes at once
        batch = db.batch()
        
        # 1. Create the master topic document
        doc_id = re.sub(r'[^a-z0-9]+', '-', topic_title.lower()).strip('-')
        master_ref = db.collection("ContentMaster").document(doc_id)
        source_doc_data = {
            "title": topic_title,
            "ai_generated": True,
            "date_updated": firestore.SERVER_TIMESTAMP,
            "lesson_content": lesson_content
        }
        batch.set(master_ref, source_doc_data)
        
        # 2. Create the first lesson_attempt document
        attempt_ref = db.collection("Users").document(user_id).collection("lesson_attempts").document()
        attempt_data = {
            "lesson_id": doc_id, 
            "title": topic_title, 
            "learning_style": learning_style,
            "started_at": firestore.SERVER_TIMESTAMP, 
            "status": "in-progress",
            "lesson_content": lesson_content, 
            "user_answers": {}, 
            "score": None,
            "questions_total": len(lesson_content.get("quiz_questions", []))
        }
        batch.set(attempt_ref, attempt_data)
        
        # 3. Commit both writes to the database
        batch.commit()
        
        # 4. Return everything the frontend needs in one go
        return jsonify({
            "lesson_id": doc_id,
            "attempt_id": attempt_ref.id,
            "content": lesson_content
        })
    except Exception as e:
        print(f"[create_custom_topic] Firestore save error: {e}")
        return jsonify({"error": "Could not save new custom topic."}), 500
    
@app.route("/generate_flashcards_lesson", methods=["POST"])
def generate_flashcards_lesson():
    data = request.get_json()
    user_id, attempt_id, count = data.get("user_id"), data.get("attempt_id"), data.get("count", 10)
    if not all([user_id, attempt_id]): return jsonify({"error": "User and Attempt ID required."}), 400
    try:
        attempt_doc = db.collection("Users").document(user_id).collection("lesson_attempts").document(attempt_id).get()
        if not attempt_doc.exists: return jsonify({"error": "Lesson attempt not found."}), 404
        lesson_context = attempt_doc.to_dict().get("lesson_content", {}).get("lesson_html", "")
        
        prompt = f'Based on the following lesson, generate exactly {count} flashcards as a JSON array. Each object must have a "question" and "answer" key. Output only the raw JSON array. ### LESSON: {lesson_context}'
        model = genai.GenerativeModel("gemini-1.5-flash")
        response = model.generate_content(prompt)

        # --- THIS IS THE FIX ---
        # Add robust error handling in case the AI returns an HTML error page.
        try:
            cards = json.loads(_strip_fences(response.text))
        except json.JSONDecodeError:
            print(f"[generate_flashcards_lesson] FAILED TO PARSE AI RESPONSE.")
            print(f"RAW AI RESPONSE WAS: {response.text}")
            return jsonify({"error": "The AI was unable to generate flashcards from this content."}), 500
        
        return jsonify({"cards": cards})
    except Exception as e:
        print(f"[generate_flashcards_lesson] Error: {e}")
        return jsonify({"error": "Failed to generate flashcards from lesson."}), 500
@app.route("/generate_flashcards_topics", methods=["POST"])
def generate_flashcards_topics():
    data = request.get_json()
    topic_ids, count = data.get("topic_ids"), data.get("count", 20)
    if not topic_ids: return jsonify({"error": "At least one Topic ID is required."}), 400
    
    all_content = []
    for topic_id in topic_ids:
        doc = db.collection("ContentMaster").document(topic_id).get()
        if doc.exists: all_content.append(doc.to_dict())

    if not all_content: return jsonify({"error": "No content found for topics."}), 404
    
    prompt = f'Based on the following combined lesson material, generate {count} flashcards as a JSON array. Each object must have a "question" and "answer" key. Output only the raw JSON array. ### MATERIAL: {json.dumps(all_content)}'
    try:
        model = genai.GenerativeModel("gemini-1.5-flash")
        response = model.generate_content(prompt)
        cards = json.loads(_strip_fences(response.text))
        return jsonify({"cards": cards})
    except Exception as e:
        print(f"[generate_flashcards_topics] Error: {e}")
        return jsonify({"error": "Failed to generate flashcards from topics."}), 500

@app.route("/export_flashcards", methods=["POST"])
def export_flashcards():
    data = request.get_json()
    file_format, title, cards = data.get("format"), data.get("title"), data.get("cards")
    if not all([file_format, title, cards]): return jsonify({"error": "Format, title, and cards are required."}), 400
    
    if file_format == "xlsx":
        output = io.BytesIO()
        workbook = Workbook()
        sheet = workbook.active
        sheet.title = "Flashcards"
        sheet.append(["Question", "Answer"])
        for card in cards:
            sheet.append([card.get("question", ""), card.get("answer", "")])
        workbook.save(output)
        output.seek(0)
        return send_file(output, as_attachment=True, download_name=f"{title}.xlsx", mimetype='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')

    elif file_format == "pdf":
        output = io.BytesIO()
        pdf = FPDF(font_cache_dir=None)
        pdf.add_page()
        pdf.set_font("Helvetica", size=12)
        
        for i, card in enumerate(cards):
            question = card.get("question", "")
            answer = card.get("answer", "")
            
            pdf.set_font("Helvetica", 'B', 12)
            # THIS IS THE FIX: The `new_x="LMARGIN"` parameter tells the library it's
            # okay to break long words if necessary, preventing the crash.
            pdf.multi_cell(0, 10, f"Q{i+1}: {question}", new_x="LMARGIN", new_y="NEXT")
            
            pdf.set_font("Helvetica", '', 12)
            pdf.multi_cell(0, 10, f"A: {answer}", new_x="LMARGIN", new_y="NEXT")
            pdf.ln(5)

        pdf_bytes = pdf.output()
        output.write(pdf_bytes)
        output.seek(0)
        return send_file(output, as_attachment=True, download_name=f"{title}.pdf", mimetype='application/pdf')

    return jsonify({"error": "Unsupported format"}), 400

# ── API: FINAL CUMULATIVE QUIZ (STATEFUL) ────────────────────────────────────────
@app.route("/generate_final_quiz", methods=["POST"])
def generate_final_quiz():
    data = request.get_json()
    user_id, topic_ids, question_count = data.get("user_id"), data.get("topic_ids"), data.get("question_count")
    if not all([user_id, topic_ids, question_count]): return jsonify({"error": "User ID, Topic IDs, and question count are required."}), 400

    all_content = []
    topic_titles = []
    try:
        for topic_id in topic_ids:
            doc = db.collection("ContentMaster").document(topic_id).get()
            if doc.exists:
                doc_dict = doc.to_dict()
                all_content.append(doc_dict)
                topic_titles.append(doc_dict.get("title", "Unknown Topic"))
    except Exception as e:
        print(f"[generate_final_quiz] Firestore error: {e}")
        return jsonify({"error": "Could not retrieve source content."}), 500
    if not all_content: return jsonify({"error": "No content found for the selected topics."}), 404

    prompt = f"""
    You are an expert financial training examiner. Your task is to create a cumulative final quiz.
    Generate exactly {question_count} unique and challenging quiz questions based on the combined source material provided below.
    The questions should synthesize information across the different topics where possible. Do not simply copy questions from the source.
    **OUTPUT REQUIREMENTS (pure JSON):** {{"quiz_questions": [{{ "question": "<string>", "options": ["A", "B", "C", "D"], "correct_answer_index": 0, "explanation": "<string>" }}]}}
    # COMBINED SOURCE MATERIAL: {json.dumps(all_content, ensure_ascii=False)}
    """
    try:
        model = genai.GenerativeModel("gemini-1.5-flash")
        raw_json = model.generate_content(prompt).text
        quiz_data = json.loads(_strip_fences(raw_json))
        final_questions = quiz_data.get("quiz_questions", [])
        if not final_questions: raise ValueError("AI did not return any questions.")
    except Exception as e:
        print(f"[generate_final_quiz] AI or JSON error: {e}")
        return jsonify({"error": "Final quiz generation failed."}), 500

    title = f"Final Quiz on {len(topic_titles)} Topics" if len(topic_titles) > 1 else f"Final Quiz: {topic_titles[0]}"
    try:
        attempt_ref = db.collection("Users").document(user_id).collection("final_quiz_attempts").document()
        attempt_ref.set({
            "title": title,
            "topic_ids": topic_ids,
            "quiz_questions": final_questions,
            "questions_total": len(final_questions),
            "started_at": firestore.SERVER_TIMESTAMP,
            "status": "in-progress",
            "score": None,
            "user_answers": {}
        })
        return jsonify({"attempt_id": attempt_ref.id, "quiz_questions": final_questions})
    except Exception as e:
        print(f"[generate_final_quiz] Firestore save error: {e}")
        return jsonify({"error": "Could not save the new final quiz."}), 500

@app.route("/submit_final_quiz", methods=["POST"])
def submit_final_quiz():
    data = request.get_json()
    user_id, attempt_id, user_answers = data.get("user_id"), data.get("attempt_id"), data.get("user_answers")
    if not all([user_id, attempt_id, user_answers]): return jsonify({"error": "User ID, Attempt ID, and answers are required."}), 400

    attempt_ref = db.collection("Users").document(user_id).collection("final_quiz_attempts").document(attempt_id)
    try:
        attempt_doc = attempt_ref.get()
        if not attempt_doc.exists: return jsonify({"error": "Final quiz attempt not found."}), 404
        
        quiz_data = attempt_doc.to_dict()
        quiz_questions = quiz_data.get("quiz_questions", [])
        
        score = 0
        for i, q in enumerate(quiz_questions):
            user_answer_index = user_answers.get(str(i))
            correct_answer_index = q.get("correct_answer_index")
            if user_answer_index is not None and int(user_answer_index) == correct_answer_index:
                score += 1
        
        attempt_ref.update({
            "user_answers": user_answers,
            "score": score,
            "status": "completed",
            "completed_at": firestore.SERVER_TIMESTAMP
        })
        
        return jsonify({
            "title": quiz_data.get("title"),
            "user_answers": user_answers,
            "score": score,
            "questions_total": len(quiz_questions),
            "quiz_questions": quiz_questions
        })
    except Exception as e:
        print(f"[submit_final_quiz] Error: {e}")
        return jsonify({"error": "Failed to score final quiz."}), 500

@app.route("/get_final_quiz_attempt", methods=["POST"])
def get_final_quiz_attempt():
    data = request.get_json()
    user_id, attempt_id = data.get("user_id"), data.get("attempt_id")
    if not user_id or not attempt_id: return jsonify({"error": "User and Attempt ID required."}), 400
    try:
        doc = db.collection("Users").document(user_id).collection("final_quiz_attempts").document(attempt_id).get()
        if not doc.exists: return jsonify({"error": "Final quiz attempt not found"}), 404
        return jsonify(doc.to_dict())
    except Exception as e:
        print(f"[get_final_quiz_attempt] Error: {e}")
        return jsonify({"error": "Could not retrieve final quiz attempt."}), 500

@app.route("/retake_final_quiz", methods=["POST"])
def retake_final_quiz():
    data = request.get_json()
    user_id, original_attempt_id = data.get("user_id"), data.get("original_attempt_id")
    if not user_id or not original_attempt_id: return jsonify({"error": "User and Original Attempt ID required."}), 400

    try:
        # Get the original quiz data
        original_doc_ref = db.collection("Users").document(user_id).collection("final_quiz_attempts").document(original_attempt_id)
        original_doc = original_doc_ref.get()
        if not original_doc.exists: return jsonify({"error": "Original final quiz not found."}), 404
        original_data = original_doc.to_dict()

        # Create a new attempt document with the same questions
        new_attempt_ref = db.collection("Users").document(user_id).collection("final_quiz_attempts").document()
        new_attempt_ref.set({
            "title": original_data.get("title") + " (Retake)",
            "topic_ids": original_data.get("topic_ids"),
            "quiz_questions": original_data.get("quiz_questions"),
            "questions_total": original_data.get("questions_total"),
            "started_at": firestore.SERVER_TIMESTAMP,
            "status": "in-progress",
            "score": None,
            "user_answers": {}
        })
        
        return jsonify({
            "attempt_id": new_attempt_ref.id,
            "quiz_questions": original_data.get("quiz_questions")
        })
    except Exception as e:
        print(f"[retake_final_quiz] Error: {e}")
        return jsonify({"error": "Could not create retake quiz."}), 500

# ── MAIN ─────────────────────────────────────────────────────────────────────────
if __name__ == "__main__":
    app.run(debug=True)

--- authenticate.py ---
import os
from google_auth_oauthlib.flow import InstalledAppFlow

# This is the scope we defined in the Google Cloud Console.
# It requests read-only access to Google Drive.
SCOPES = ['https://www.googleapis.com/auth/drive.readonly']

def main():
    """
    This function handles the user authentication flow.
    """
    creds = None
    
    # The file token.json stores the user's access and refresh tokens.
    # It is created automatically when the authorization flow completes for the first time.
    if os.path.exists('token.json'):
        print("Token file already exists. Authentication successful.")
        return

    # If there are no (valid) credentials available, let the user log in.
    # This will read your 'client_secret.json' file.
    flow = InstalledAppFlow.from_client_secrets_file(
        'client_secret.json', SCOPES)
    
    # This line will automatically open a browser window for you to log in.
    creds = flow.run_local_server(port=8080)
    
    # Save the credentials for the next run
    with open('token.json', 'w') as token:
        token.write(creds.to_json())
        
    print("Authentication successful! A 'token.json' file has been created.")

if __name__ == '__main__':
    main()

--- export.js ---
const fs = require("fs");
const path = require("path");

const allowedExtensions = [".js", ".json", ".html", ".css", ".md", ".py"];
const ignoredDirs = ["node_modules", "venv", "__pycache__", ".git"];
const ignoredFiles = [
  "exportProject.js",
  "client_secret.json",
  "token.json",
  "gitignore",
  "content_library.json",
];

function shouldIgnore(filePath) {
  return ignoredDirs.some((dir) =>
    filePath.includes(path.sep + dir + path.sep)
  );
}

function gatherFiles(dir, collected = []) {
  const entries = fs.readdirSync(dir);
  for (const entry of entries) {
    const fullPath = path.join(dir, entry);
    const stats = fs.statSync(fullPath);
    if (stats.isDirectory()) {
      if (!ignoredDirs.includes(entry)) {
        gatherFiles(fullPath, collected);
      }
    } else if (
      allowedExtensions.includes(path.extname(entry)) &&
      !shouldIgnore(fullPath) &&
      !ignoredFiles.includes(entry)
    ) {
      collected.push(fullPath);
    }
  }
  return collected;
}

function exportFiles() {
  const files = gatherFiles(".");
  const output = [];

  for (const file of files) {
    const content = fs.readFileSync(file, "utf8");
    output.push(`--- ${file} ---\n${content}`);
  }

  fs.writeFileSync("project_export.txt", output.join("\n\n"));
  console.log(
    `✅ Export complete! ${files.length} files written to project_export.txt`
  );
}

exportFiles();


--- parser.py ---
import os.path
import json
import datetime
from google.auth.transport.requests import Request
from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import InstalledAppFlow
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError
from google.cloud import firestore # <-- NEW IMPORT

SCOPES = ['https://www.googleapis.com/auth/drive.readonly']
TOC_DOCUMENT_URL = 'https://docs.google.com/document/d/1RFGdf5q8kHueTwThJvt7ITkhsSqsin39hHl5ugIveX8/edit?usp=sharing'

def get_credentials():
    """Handles user authentication and returns valid credentials."""
    creds = None
    if os.path.exists('token.json'):
        creds = Credentials.from_authorized_user_file('token.json', SCOPES)
    if not creds or not creds.valid:
        if creds and creds.expired and creds.refresh_token:
            creds.refresh(Request())
        else:
            flow = InstalledAppFlow.from_client_secrets_file(
                'client_secret.json', SCOPES)
            creds = flow.run_local_server(port=8081)
        with open('token.json', 'w') as token:
            token.write(creds.to_json())
    return creds

def read_paragraph_text(elements):
    """Reads the text from a list of paragraph elements."""
    text = ''
    for element in elements:
        if 'textRun' in element:
            text += element.get('textRun').get('content')
    return text

def get_lesson_urls(docs_service, document_id):
    """Reads the TOC doc and extracts all lesson URLs."""
    # This function remains the same as before.
    print("Reading Table of Contents to find lesson URLs...")
    urls = {}
    try:
        document = docs_service.documents().get(documentId=document_id).execute()
        content = document.get('body').get('content')
        for element in content:
            if 'paragraph' in element:
                para_elements = element.get('paragraph').get('elements')
                for para_element in para_elements:
                    if 'textRun' in para_element:
                        text_run = para_element.get('textRun')
                        text_style = text_run.get('textStyle')
                        if text_style and 'link' in text_style:
                            text = text_run.get('content').strip()
                            url = text_style.get('link').get('url')
                            if text and url and 'docs.google.com' in url:
                                urls[text] = url
        print(f"Found {len(urls)} lesson links.")
        return urls
    except HttpError as err:
        print(f"Error reading TOC: {err}")
        return {}

def parse_lesson_doc(docs_service, title, url):
    """
    Reads a single lesson doc and intelligently parses it into structured sections.
    """
    print(f"  -> Parsing lesson: '{title}'")
    try:
        doc_id = url.split('/d/')[1].split('/')[0]
        document = docs_service.documents().get(documentId=doc_id).execute()
        content = document.get('body').get('content')
        
        today_date = datetime.date.today().isoformat()
        lesson_data = {
            'title': title,
            'url': url,
            'version': '1.0',
            'date_updated': today_date,
            'goal': '',
            'outcomes': [],
            'talking_points': '',
            'resources': [],
            'philosophy': '',
            'other_notes': '',
            'tasks': []
        }
        
        current_section = None
        
        for element in content:
            if 'paragraph' in element:
                para = element.get('paragraph')
                text = read_paragraph_text(para.get('elements')).strip()

                if not text:
                    continue

                if text.startswith('Version:'):
                    lesson_data['version'] = text.replace('Version:', '').strip()
                    current_section = None
                elif text.startswith('Date:'):
                    lesson_data['date_updated'] = text.replace('Date:', '').strip()
                    current_section = None
                elif text.startswith('Chapter Goal:'):
                    current_section = 'goal'
                    lesson_data['goal'] = text.replace('Chapter Goal:', '').strip()
                elif text.startswith('By the end of this chapter you will be able to:'):
                    current_section = 'outcomes'
                elif text.startswith('Advisor Talking Points (Cliff Version):'):
                    current_section = 'talking_points'
                    lesson_data['talking_points'] = text.replace('Advisor Talking Points (Cliff Version):', '').strip()
                elif text.startswith('Key Advisor Tools/Resources:'):
                    current_section = 'resources'
                elif text.startswith('Abundo Philosophy:'):
                    current_section = 'philosophy'
                    lesson_data['philosophy'] = text.replace('Abundo Philosophy:', '').strip()
                elif text.startswith('Other Notes:'):
                    current_section = 'other_notes'
                    lesson_data['other_notes'] = text.replace('Other Notes:', '').strip()
                elif text.startswith('Chapter Task List'):
                    current_section = 'tasks'
                else:
                    if current_section == 'goal':
                        lesson_data['goal'] += ' ' + text
                    elif current_section == 'outcomes':
                        lesson_data['outcomes'].append(text)
                    elif current_section == 'talking_points':
                        lesson_data['talking_points'] += ' ' + text
                    elif current_section == 'resources':
                        lesson_data['resources'].append(text)
                    elif current_section == 'philosophy':
                        lesson_data['philosophy'] += ' ' + text
                    elif current_section == 'other_notes':
                        lesson_data['other_notes'] += ' ' + text
                    elif current_section == 'tasks':
                        is_bold = para.get('elements')[0].get('textRun').get('textStyle').get('bold', False)
                        if is_bold:
                            lesson_data['tasks'].append({'title': text, 'description': ''})
                        elif lesson_data['tasks']:
                            lesson_data['tasks'][-1]['description'] += ' ' + text
        
        return lesson_data

    except HttpError as err:
        print(f"    ERROR: Could not parse doc '{title}'. Reason: {err}")
        return None

def main():
    """Main function to run the parser and upload to Firestore."""
    creds = get_credentials()
    docs_service = build('docs', 'v1', credentials=creds)
    
    toc_doc_id = TOC_DOCUMENT_URL.split('/d/')[1].split('/')[0]
    lesson_urls = get_lesson_urls(docs_service, toc_doc_id)

    if not lesson_urls:
        print("No lesson URLs found. Exiting.")
        return

    # --- NEW FIRESTORE LOGIC ---
    # Initialize Firestore client
    db = firestore.Client()
    print("\nUploading lessons to Firestore...")

    for title, url in lesson_urls.items():
        if "Getting Started" in title or "The Abundo High Five" in title:
            print(f"  -> Skipping non-lesson doc: '{title}'")
            continue
        
        lesson_data = parse_lesson_doc(docs_service, title, url)
        if lesson_data:
            # We will use the lesson title as the unique ID for the document.
            # We replace slashes to make it a valid ID.
            doc_id = title.replace('/', '-')
            
            # Get a reference to the document and upload the data
            doc_ref = db.collection('ContentMaster').document(doc_id)
            doc_ref.set(lesson_data)
            print(f"    -> Successfully uploaded '{title}'")
    
    print("\nSUCCESS! All content has been uploaded to the Firestore 'ContentMaster' collection.")

if __name__ == '__main__':
    main()

--- read_docs.py ---
import os.path
from google.auth.transport.requests import Request
from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import InstalledAppFlow
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError

SCOPES = ['https://www.googleapis.com/auth/drive.readonly']

def main():
    creds = None
    if os.path.exists('token.json'):
        creds = Credentials.from_authorized_user_file('token.json', SCOPES)
    
    if not creds or not creds.valid:
        if creds and creds.expired and creds.refresh_token:
            creds.refresh(Request())
        else:
            flow = InstalledAppFlow.from_client_secrets_file(
                'client_secret.json', SCOPES)
            creds = flow.run_local_server(port=8080)
        with open('token.json', 'w') as token:
            token.write(creds.to_json())

    try:
        docs_service = build('docs', 'v1', credentials=creds)

        doc_url = 'https://docs.google.com/document/d/1RFGdf5q8kHueTwThJvt7ITkhsSqsin39hHl5ugIveX8/edit?usp=sharing'
        
        document_id = doc_url.split('/d/')[1].split('/')[0]

        document = docs_service.documents().get(documentId=document_id).execute()
        
        print(f"SUCCESS! Reading links from document: '{document.get('title')}'")
        print("-" * 30)

        # --- UPDATED CODE STARTS HERE ---
        doc_content = document.get('body').get('content')
        
        print("Found the following links:")
        
        # Loop through each structural element in the document
        for element in doc_content:
            if 'paragraph' in element:
                para_elements = element.get('paragraph').get('elements')
                for para_element in para_elements:
                    if 'textRun' in para_element:
                        text_run = para_element.get('textRun')
                        
                        # Check if this textRun has a link style attached
                        text_style = text_run.get('textStyle')
                        if text_style and 'link' in text_style:
                            # It's a link! Let's get the text and the URL.
                            visible_text = text_run.get('content').strip()
                            url = text_style.get('link').get('url')
                            
                            # We only want to print if both text and URL exist
                            if visible_text and url:
                                print(f"  - {visible_text} -> {url}")
        # --- UPDATED CODE ENDS HERE ---

    except HttpError as err:
        print(err)

if __name__ == '__main__':
    main()

--- sample_lesson.md ---
# Paying Down or Paying Off Debt (Including Refinancing)

**URL:** [Google Doc Link](if applicable)  
**Version:** 1.0  
**Last Updated:** 2025-06-21

---

## Goal

Develop a personalized debt management strategy that aligns with your financial goals, enabling you to systematically reduce or eliminate debt while maintaining balance with other priorities.

---

## Outcomes

- Understand the true cost of each debt in your financial picture
- Prioritize debts strategically based on financial and psychological factors
- Evaluate refinancing opportunities to potentially reduce interest costs
- Create a systematic debt reduction plan that fits your budget and timeline
- Balance debt repayment with other important financial goals
- Determine when it makes mathematical sense to pay extra on debts versus investing
- Recognize and avoid common debt management pitfalls and predatory practices

---

## Talking Points

This chapter helps clients take control of their debt by first categorizing it (high-interest vs low-interest, secured vs unsecured) and then creating a systematic plan for reduction. Many clients struggle with deciding whether to focus on debt repayment or investing; we'll help them understand when each makes mathematical sense while acknowledging that the psychological benefits of debt freedom may outweigh pure math for some.

For those with multiple debts, we'll explore both the **debt snowball** (smallest balance first) and **debt avalanche** (highest interest first) methods. Refinancing opportunities can be valuable tools, but we'll evaluate them carefully to ensure the costs don't outweigh the benefits. The ultimate goal is to help clients use debt strategically when it serves their goals while methodically eliminating burdensome debt that restricts their choices.

---

## Resources

- RightCapital debt management module
- _The Path to Getting Out of Debt_ (blog post)
- Student Loans & [StudentAid.gov](https://studentaid.gov) resource (including Loan Simulator tool)
- Debt payoff calculators (snowball vs. avalanche comparison)
- Debt Free Charts
- [Bankrate Mortgage Refinance Calculator](https://www.bankrate.com/calculators/mortgages/refinance-calculator.aspx)
- [Bankrate Current Mortgage Rates](https://www.bankrate.com/mortgages/mortgage-rates/)
- Abundo’s quarterly interest rate presentations
- [AnnualCreditReport.com](https://www.annualcreditreport.com/)

---

## Philosophy

At Abundo, we believe that not all debt is created equal, and our approach recognizes that some debt can be strategic (like low-interest mortgages) while other debt is destructive (like high-interest credit cards). We don't take a one-size-fits-all approach to debt elimination—instead, we help clients make intentional choices based on their unique financial situation and goals.

While we value the peace of mind that comes with debt freedom, we're also pragmatic about the opportunity costs of aggressive debt repayment versus investing. Our approach to refinancing is deliberately cautious—we analyze fees, interest savings, and time horizons to ensure clients genuinely benefit from any restructuring.

---

## Other Notes

Clients often have emotional associations with debt that can interfere with objective decision-making. Some may feel intense shame or anxiety around debt, leading to avoidance behaviors, while others may have become too comfortable with debt as a lifestyle enabler.

When discussing debt management, be sensitive to these emotional factors while still helping clients move toward more strategic choices. For couples, debt discussions can be particularly charged if they have different money scripts or if one partner brought significantly more debt into the relationship.

Also remain aware of unique considerations for different debt types—student loans have repayment options that other debts don't, while mortgage decisions should factor in tax implications and housing market conditions. Note the behavioral risk of refinancing: a consolidation loan or 0% transfer can lead to more total debt if chronic overspending is an issue.

---

## Tasks

### 1. Complete Your Debt Inventory

Create a comprehensive list of all debts, including creditor name, current balance, interest rate, minimum payment, payment due date, and estimated payoff date at current payment levels. Note whether each debt is fixed or variable rate, and whether it's secured by any assets. This gives you the complete picture needed to develop a strategic plan.

### 2. Evaluate Refinancing Opportunities

Research current interest rates for each type of debt you carry. For each debt, determine if refinancing might save you money by calculating total interest costs under current terms versus potential new terms. Remember to include any fees or closing costs in your calculations to determine true break-even points. Flag debts with the highest potential savings for immediate action.

### 3. Choose Your Debt Payoff Strategy

After reviewing the mathematical benefits of the **debt avalanche** method (highest interest first) and the psychological benefits of the **debt snowball** method (smallest balance first), select your preferred approach. Create a detailed payoff schedule with target dates for each debt and track your progress visually to maintain motivation.

### 4. Create Debt Reduction Acceleration Plan

Identify at least 3–5 specific actions you can take to accelerate your debt payoff, such as redirecting windfalls (tax refunds, bonuses, gifts), eliminating specific expenses temporarily, or generating additional income. Commit to specific dollar amounts from each source and add them to your debt payoff schedule.

### 5. Set Up Payment Automation

Automate minimum payments for all debts to avoid late fees and credit damage. For the debt you're prioritizing first, set up an additional automatic payment on a specific date each month to accelerate payoff. This removes the decision-making friction that often prevents consistent extra payments.

### 6. Establish Guardrails Against New Debt

Create specific guidelines for when you would consider taking on new debt in the future. Define what types of debt align with your values and financial goals (if any) and establish criteria any new debt must meet before you would consider it. Consider implementing a mandatory waiting period or consultation process before any new debt.

### 7. Create Celebration Milestones

Identify specific milestones in your debt payoff journey (25% paid, 50% paid, first debt completely eliminated, etc.) and plan meaningful but affordable celebrations for each achievement. Having planned rewards increases motivation and acknowledges the discipline required for successful debt reduction.

### 8. Review and Update Protection Strategies

Evaluate your insurance coverage and emergency fund in light of your debts. Ensure you have adequate protection to prevent a financial setback from derailing your debt payoff plan. Consider whether disability insurance or increased emergency savings might be needed while you're focusing on debt elimination.

### 9. Schedule Quarterly Debt Strategy Check-ins

Set calendar reminders to review your debt reduction progress and strategy every three months. During these check-ins, assess whether your chosen method is working, whether any refinancing opportunities have emerged, and whether your balance between debt payoff and other financial goals still feels appropriate.


--- static/js/main.js ---
/* FILE: static/js/main.js
   Paramigo Front-End  —  FULL MERGE  •  24 Jun 2025
   ─────────────────────────────────────────────────────────────────────────
   ▸ Restores Firebase auth & the entire SPA workflow
   ▸ Adds source-material accordion, Create-Topic, flashcards, export
   ▸ Modernises utilities & CSS hooks
*/

/* ───── 1.  ES-MODULE IMPORTS & FIREBASE SETUP ────────────────────────── */
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js";
import {
  getAuth,
  onAuthStateChanged,
  GoogleAuthProvider,
  signInWithPopup,
  signOut,
} from "https://www.gstatic.com/firebasejs/10.12.0/firebase-auth.js";

const firebaseConfig = {
  apiKey: "AIzaSyB4EJ5fu2ZGn3YG6NerCZRHfLj3F1mvpww",
  authDomain: "paramigo-tool-03.firebaseapp.com",
  projectId: "paramigo-tool-03",
  storageBucket: "paramigo-tool-03.firebasestorage.app",
  messagingSenderId: "626376082375",
  appId: "1:626376082375:web:7b0edfa3319c258d900fe2",
  measurementId: "G-5C44175E71",
};
const fbApp = initializeApp(firebaseConfig);
const auth = getAuth(fbApp);

/* ───── 2.  DOM HELPERS & BASE UTILITIES ──────────────────────────────── */
const $ = (sel, p = document) => p.querySelector(sel);
const $$ = (sel, p = document) => [...p.querySelectorAll(sel)];
const el = (tag, cls = "", txt = "") => {
  const n = document.createElement(tag);
  if (cls) n.className = cls;
  if (txt) n.textContent = txt;
  return n;
};
const sleep = (ms) => new Promise((r) => setTimeout(r, ms));

async function post(url, body) {
  const r = await fetch(url, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body),
  });
  if (!r.ok) throw new Error((await r.json()).error || r.statusText);
  return r.json();
}

/* Ensure options field is always an array (defensive) */
function normalizeOptions(opt) {
  if (Array.isArray(opt)) return opt;
  if (typeof opt === "string") {
    const matches = opt.match(/[A-Z]\)[^A-Z]*/g);
    return (matches || opt.split(/[;,]/)).map((s) => s.trim());
  }
  return [];
}

function formatSourceMaterialAsHtml(source) {
  // NEW: Handle AI-generated source material, which has a different structure.
  if (source.ai_generated && source.lesson_content) {
    let html = "<h3>AI-Generated Lesson Content</h3>";
    html += source.lesson_content.lesson_html;
    return html;
  }

  // Fallback for original, human-written source material.
  let html = "";
  if (source.goal) {
    html += `<h3>Goal</h3><p>${source.goal}</p>`;
  }
  if (source.outcomes && source.outcomes.length) {
    html += `<h3>Outcomes</h3><ul>${source.outcomes
      .map((o) => `<li>${o}</li>`)
      .join("")}</ul>`;
  }
  if (source.talking_points) {
    html += `<h3>Talking Points</h3><p>${source.talking_points}</p>`;
  }
  if (source.philosophy) {
    html += `<h3>Philosophy</h3><p>${source.philosophy}</p>`;
  }
  if (source.resources && source.resources.length) {
    html += `<h3>Resources</h3><ul>${source.resources
      .map((r) => `<li>${r}</li>`)
      .join("")}</ul>`;
  }
  if (source.tasks && source.tasks.length) {
    html += `<h3>Tasks</h3><dl>${source.tasks
      .map(
        (t) => `<dt><strong>${t.title}</strong></dt><dd>${t.description}</dd>`
      )
      .join("")}</dl>`;
  }
  if (source.other_notes) {
    html += `<h3>Other Notes</h3><p>${source.other_notes}</p>`;
  }
  return html || "<p>No structured source material found.</p>";
}

/* ───── 3.  GLOBAL STATE & DOM REFERENCES ─────────────────────────────── */
let currentUser = null;
let currentAttemptId = null;
let currentLessonId = null;
let currentLessonContext = null;
let libraryData = [];
let currentFinalQuizQuestions = [];
let FLASHCARDS = [];

const loginContainer = $("#login-container");
const appContainer = $("#app-container");
const userNameSpan = $("#user-name");
const flashcardTopicModal = $("#flashcard-topic-modal");
const flashcardTopicSelectionList = $("#flashcard-topic-selection-list");
const generateFlashcardsBtnModal = $("#generate-flashcards-btn-modal");
const cancelFlashcardsBtnModal = $("#cancel-flashcards-btn-modal");
const selectAllFlashcardTopicsCheckbox = $(
  "#select-all-flashcard-topics-checkbox"
);

const views = {
  library: $("#lesson-library-view"),
  topicDetail: $("#topic-detail-view"),
  lesson: $("#lesson-taking-view"),
  results: $("#results-view"),
  finalQuiz: $("#final-quiz-view"),
};
const tutorButton = $("#tutor-button");
const tutorChatContainer = $("#tutor-chat-container");
const tutorChatHistory = $("#tutor-chat-history");
const tutorInput = $("#tutor-input");

const finalQuizModal = $("#final-quiz-modal");
const topicSelectionList = $("#topic-selection-list");
const generateFinalQuizBtn = $("#generate-final-quiz-btn");
const cancelFinalQuizBtn = $("#cancel-final-quiz-btn");
const questionCountInput = $("#question-count-input");
const selectAllTopicsCheckbox = $("#select-all-topics-checkbox");

/* ───── 4.  VIEW HELPERS ──────────────────────────────────────────────── */
function showView(name) {
  Object.values(views).forEach((v) => (v.style.display = "none"));
  views[name].style.display = "block";
  tutorButton.style.display =
    name === "lesson" || name === "results" ? "block" : "none";
  window.scrollTo(0, 0);
}
window.showView = showView; // Expose to global scope

/* ───── 5. LIBRARY & DASHBOARD RENDERING ─────────────────────────────── */
async function initializeAppForUser(user) {
  currentUser = user;

  // ===== [THIS LINE IS MODIFIED] =====
  // Now expects four items from the backend, including the learning style
  const { library, user_creations, final_quiz_history, learningStyle } =
    await post("/get_library_and_history", { user_id: user.uid });

  // ===== [THIS BLOCK IS NEW] =====
  // Update the new learning style display in the header
  const styleDisplay = $("#current-learning-style");
  if (styleDisplay) {
    styleDisplay.textContent = `"${learningStyle || "Not Set"}"`;
  }
  // ===============================

  const safeUserCreations = user_creations || [];
  libraryData = [...(library || []), ...safeUserCreations]; // Combine for other parts of the app

  const dynamicArea = $("#library-dynamic-area", views.library);
  if (!dynamicArea)
    return console.error("Critical error: #library-dynamic-area not found!");

  const renderTopicList = (topics, isUserCreated = false) => {
    return topics
      .map(
        (t) => `
      <li class="lesson-item" onclick="showTopicDetail('${t.id}')">
        <span class="lesson-title">${t.title}</span>
        ${
          t.attempts.length
            ? '<span class="lesson-item-indicator">✔ Started</span>'
            : ""
        }
        ${
          isUserCreated
            ? `<button class="delete-topic-btn" onclick="event.stopPropagation(); deleteCustomTopic('${t.id}', '${t.title}')">Delete</button>`
            : ""
        }
      </li>
    `
      )
      .join("");
  };

  let libraryHtml =
    "<h2>Lesson Library</h2><p>Select a topic to begin or review your history.</p>";
  libraryHtml += `<ul id="lesson-list">${renderTopicList(library || [])}</ul>`;

  if (safeUserCreations.length > 0) {
    libraryHtml += `
      <hr style="margin:2em 0">
      <h3>Your Created Topics</h3>
      <ul id="user-creations-list">${renderTopicList(
        safeUserCreations,
        true
      )}</ul>
    `;
  }

  // Inject the button between the created topics and the final quiz history.
  libraryHtml += `
    <hr style="margin:2em 0; border-top: 1px solid var(--c-border);">
    <button id="final-quiz-button" class="btn-outline" style="width:100%; text-align:center;">
        Take a Final Quiz
    </button>
  `;

  if (final_quiz_history?.length) {
    libraryHtml += `
      <hr style="margin:2em 0; border-top: 1px solid var(--c-border);">
      <h3>Final Quiz History</h3>
      <ul id="final-quiz-history-list">
        ${final_quiz_history
          .map(
            (h) => `
          <li class="attempt-item" onclick="reviewFinalQuiz('${h.attempt_id}')">
            <strong>${h.title}</strong><br>
            Score: ${
              h.score !== null
                ? `${h.score}/${h.questions_total}`
                : "In Progress"
            }<br>
            <small>${new Date(h.started_at).toLocaleString()}</small>
          </li>
        `
          )
          .join("")}
      </ul>`;
  }

  dynamicArea.innerHTML = libraryHtml;

  // This event listener will now find the button we just injected into the HTML.
  if ($("#final-quiz-button")) {
    $("#final-quiz-button").addEventListener("click", showFinalQuizModal);
  }

  showView("library");
}

/* ───── 6.  LESSON FLOW ──────────────────────────────────────────────── */
async function startLesson(lessonId, originalAttemptId = null) {
  views.lesson.innerHTML = "<h2>Loading Lesson…</h2>";
  showView("lesson");
  try {
    const payload = { user_id: currentUser.uid, lesson_id: lessonId };
    if (originalAttemptId) payload.original_attempt_id = originalAttemptId;

    const data = await post("/start_lesson", payload);
    currentAttemptId = data.attempt_id;
    currentLessonId = data.lesson_id;
    currentLessonContext = data.content;
    renderLesson(data.content, data.lesson_id);
  } catch (e) {
    views.lesson.innerHTML = `<h2>Error</h2><p>${e.message}</p>`;
  }
}
window.startLesson = startLesson;

/* MAIN LESSON RENDERER (adds accordion & flashcards) */
async function renderLesson(content, lessonId) {
  const root = views.lesson;
  const { lesson_html, quiz_questions } = content;

  /* Lesson body */
  root.innerHTML = `<div>${lesson_html}</div>`;

  /* -- FEATURE: Accordion with raw source material -- */
  try {
    const src = await post("/get_source_material", {
      user_id: currentUser.uid,
      lesson_id: lessonId,
    });
    const acc = el("div", "accordion");
    const head = el("button", "accordion-head", "Show Source Material");
    const body = el("div", "accordion-body"); // Changed from <pre> to <div>

    // FIX: Use the new formatter function
    body.innerHTML = formatSourceMaterialAsHtml(src);

    body.style.display = "none";
    head.onclick = () => {
      const open = body.style.display === "block";
      body.style.display = open ? "none" : "block";
      head.textContent = open ? "Show Source Material" : "Hide Source Material";
    };
    acc.append(head, body);
    root.append(acc);
  } catch (err) {
    console.warn("Accordion error:", err.message);
  }

  /* Flashcards button */
  const fcBtn = el("button", "btn-primary", "Generate Flashcards");
  fcBtn.style.marginTop = "1.5em";
  fcBtn.onclick = genFlashcardsLesson;
  root.append(fcBtn);

  /* Quiz */
  const shuffled = [...quiz_questions].sort(() => Math.random() - 0.5);
  const quizHtml = shuffled
    .map((q, i) => {
      const origIndex = quiz_questions.indexOf(q);
      const opts = normalizeOptions(q.options)
        .map(
          (o, j) =>
            `<label><input type="radio" name="${origIndex}" value="${j}" required><span>${o}</span></label>`
        )
        .join("");
      return `<div class="quiz-question"><h4>${i + 1}. ${
        q.question
      }</h4><div class="quiz-options">${opts}</div></div>`;
    })
    .join("");

  root.insertAdjacentHTML(
    "beforeend",
    `<form id="quiz-form" style="margin-top:2em">
        <h3>Check Your Understanding</h3>
        ${quizHtml}
        <button type="button" class="btn-primary" onclick="submitQuiz()">Submit & Score My Quiz</button>
     </form>
     <button class="back-to-library" onclick="showTopicDetail('${lessonId}')" style="margin-top:1em;background:#6c757d">Cancel and Go Back</button>`
  );
}

/* Submit quiz */
async function submitQuiz() {
  const formData = new FormData($("#quiz-form"));
  const userAnswers = Object.fromEntries(formData.entries());
  views.results.innerHTML = "<h2>Scoring…</h2>";
  showView("results");
  try {
    const data = await post("/submit_quiz", {
      user_id: currentUser.uid,
      attempt_id: currentAttemptId,
      user_answers: userAnswers,
      lesson_id: currentLessonId,
    });
    currentLessonContext = data.content;
    renderResultsView(data, currentAttemptId);
  } catch (e) {
    views.results.innerHTML = `<h2>Error</h2><p>${e.message}</p>`;
  }
}
window.submitQuiz = submitQuiz;

/* Render quiz RESULTS with Source Material Accordion */
async function renderResultsView(data, attemptId) {
  const {
    lesson_id,
    content,
    user_answers,
    score,
    questions_total,
    smart_focus,
  } = data;

  // Start building the HTML
  let html = `<h2>Reviewing: ${content.title || "Lesson"}</h2>`;

  // Fetch and format the source material before rendering
  try {
    const src = await post("/get_source_material", {
      user_id: currentUser.uid,
      lesson_id: lesson_id,
    });
    // Build the accordion HTML as a string
    html += `
      <div class="accordion">
        <button class="accordion-head" onclick="this.nextElementSibling.style.display = this.nextElementSibling.style.display === 'block' ? 'none' : 'block'">Show Source Material</button>
        <div class="accordion-body" style="display: none;">${formatSourceMaterialAsHtml(
          src
        )}</div>
      </div>
    `;
  } catch (err) {
    console.warn("Accordion error:", err.message);
  }

  // Add the AI-Generated Lesson and Score Summary
  html += `
    <details class="lesson-accordion"><summary>Click to review AI-Generated Lesson</summary><div>${content.lesson_html}</div></details>
    <hr style="margin:2em 0">
    <div class="results-summary"><h3>Your Score: ${score} / ${questions_total}</h3></div>
  `;

  // Render the question-by-question results
  html += content.quiz_questions
    .map((q, i) => {
      const opts = normalizeOptions(q.options)
        .map((o, j) => {
          let cls = "option",
            icon = "⚪";
          if (j === q.correct_answer_index) {
            cls += " correct";
            icon = "✅";
          } else if (String(j) === user_answers[i]) {
            cls += " incorrect-selection";
            icon = "❌";
          }
          return `<div class="${cls}"><span class="icon">${icon}</span> ${o}</div>`;
        })
        .join("");
      return `<div class="results-question"><h4>${i + 1}. ${
        q.question
      }</h4><div class="results-options">${opts}</div><div class="explanation"><strong>Explanation:</strong> ${
        q.explanation
      }</div></div>`;
    })
    .join("");

  // Add the Smart Focus prompt if needed
  if (smart_focus?.smart_focus_needed) {
    const list = smart_focus.missed_concepts
      .map((c) => `<li><strong>${c}</strong></li>`)
      .join("");
    html += `
      <div class="smart-focus-prompt">
        <h3>💡 Smart Focus Opportunity</h3>
        <p>Looks like you struggled with:</p><ul>${list}</ul>
        <hr>
        <p><strong>Quick refresher:</strong> ${smart_focus.explanation}</p>
        <button id="generate-focus-lesson-btn">Generate a lesson on these</button>
      </div>`;
  }

  // Add the final action buttons
  html += `
    <div class="results-actions">
      <button onclick="showTopicDetail('${lesson_id}')">← Back to Topic</button>
      <button onclick="startLesson('${lesson_id}','${attemptId}')">Retake Quiz</button>
      <button class="delete-btn" onclick="deleteAttempt('${attemptId}','${lesson_id}')">Delete Attempt</button>
    </div>`;

  // Set the final HTML and add event listeners
  views.results.innerHTML = html;

  $("#generate-focus-lesson-btn")?.addEventListener("click", () =>
    startMultiConceptLesson(smart_focus.missed_concepts, lesson_id)
  );
}

/* Delete attempt */
async function deleteAttempt(attemptId, lessonId) {
  if (!confirm("Really delete this attempt?")) return;
  await post("/delete_attempt", {
    user_id: currentUser.uid,
    attempt_id: attemptId,
  });
  await initializeAppForUser(currentUser);
  showTopicDetail(lessonId);
}
window.deleteAttempt = deleteAttempt;

// Permanently deletes a custom topic and all its history
async function deleteCustomTopic(topicId, topicTitle) {
  if (
    !confirm(
      `Are you sure you want to permanently delete the topic "${topicTitle}" and all of your attempts? This cannot be undone.`
    )
  ) {
    return;
  }
  try {
    await post("/delete_custom_topic", {
      user_id: currentUser.uid,
      topic_id: topicId,
    });
    // Refresh the library view to show the topic is gone
    await initializeAppForUser(currentUser);
  } catch (e) {
    alert(`Failed to delete topic: ${e.message}`);
  }
}
window.deleteCustomTopic = deleteCustomTopic;

/* Review past attempt */
async function reviewLesson(attemptId) {
  views.results.innerHTML = "<h2>Loading…</h2>";
  showView("results");
  try {
    const data = await post("/get_lesson_attempt", {
      user_id: currentUser.uid,
      attempt_id: attemptId,
    });
    currentLessonContext = data.content;
    currentLessonId = data.lesson_id;
    renderResultsView(data, attemptId);
  } catch (e) {
    views.results.innerHTML = `<h2>Error</h2><p>${e.message}</p>`;
  }
}
window.reviewLesson = reviewLesson;

/* ───── 7.  SMART-FOCUS LESSON ────────────────────────────────────────── */
async function startMultiConceptLesson(concepts, parentLessonId) {
  views.lesson.innerHTML = "<h2>Generating Focused Lesson…</h2>";
  showView("lesson");
  try {
    const data = await post("/start_multi_concept_lesson", {
      user_id: currentUser.uid,
      concepts,
      parent_lesson_id: parentLessonId,
    });
    currentAttemptId = data.attempt_id;
    currentLessonId = data.lesson_id;
    currentLessonContext = data.content;
    renderLesson(data.content, data.lesson_id);
  } catch (e) {
    views.lesson.innerHTML = `<h2>Error</h2><p>${e.message}</p>`;
  }
}
window.startMultiConceptLesson = startMultiConceptLesson;

/* ───── 8.  FLASHCARDS (lesson & multi-topic) ─────────────────────────── */
function showCards(cards, heading) {
  $("#flash-modal")?.remove();
  const ov = el("div", "modal-ov");
  ov.id = "flash-modal";
  const md = el("div", "modal");
  md.append(el("h3", "", heading));

  const deck = el("div", "deck");
  cards.forEach((c) => {
    const card = el("div", "card");
    const front = el("div", "face front", c.question);
    const back = el("div", "face back", c.answer);
    card.append(front, back);
    card.onclick = () => card.classList.toggle("flip");
    deck.append(card);
  });
  md.append(deck);

  const exp = el("div", "export");
  const pdf = el("button", "btn-outline", "PDF");
  const xls = el("button", "btn-outline", "Spreadsheet");

  // FIX: Pass the button element to the export function for loading state
  pdf.onclick = (e) => exportCards("pdf", heading, e.target);
  xls.onclick = (e) => exportCards("xlsx", heading, e.target);

  exp.append(pdf, xls);
  md.append(exp);

  const closeBtn = el("button", "close", "×");

  // FIX: Make close button and background overlay work correctly
  closeBtn.onclick = () => ov.remove();
  ov.onclick = () => ov.remove();
  md.onclick = (e) => e.stopPropagation(); // Prevents click inside modal from closing it

  md.append(closeBtn);
  ov.append(md);
  document.body.append(ov);
}

async function genFlashcardsLesson() {
  // FIX: Add loading state to the button that was clicked ('this')
  const btn = this;
  const originalText = btn.textContent;
  btn.disabled = true;
  btn.textContent = "Generating...";

  try {
    const { cards } = await post("/generate_flashcards_lesson", {
      user_id: currentUser.uid,
      attempt_id: currentAttemptId,
      count: 12,
    });
    FLASHCARDS = cards;
    showCards(cards, "Flashcards");
  } catch (e) {
    alert("Flashcard error: " + e.message);
  } finally {
    // Always restore the button after the attempt
    btn.disabled = false;
    btn.textContent = originalText;
  }
}

async function genFlashcardsTopics(ids) {
  // FIX: Add loading state to the library flashcard button
  const btn = $("#library-flashcards-btn");
  const originalText = btn.textContent;
  btn.disabled = true;
  btn.textContent = "Generating...";

  try {
    const { cards } = await post("/generate_flashcards_topics", {
      user_id: currentUser.uid,
      topic_ids: ids,
      count: 25,
    });
    FLASHCARDS = cards;
    showCards(cards, "Multi-Topic Flashcards");
  } catch (e) {
    alert("Flashcard error: " + e.message);
  } finally {
    // Always restore the button after the attempt
    btn.disabled = false;
    btn.textContent = originalText;
  }
}

async function exportCards(format, title, btn) {
  // FIX: Add loading state to the export button
  const originalText = btn.textContent;
  btn.disabled = true;
  btn.textContent = "Exporting...";

  try {
    const blob = await (
      await fetch("/export_flashcards", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ format, title, cards: FLASHCARDS }),
      })
    ).blob();
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download =
      title.replace(/\s+/g, "_") + (format === "pdf" ? ".pdf" : ".xlsx");
    document.body.append(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  } catch (e) {
    alert("Export failed: " + e.message);
  } finally {
    // Always restore the button after the attempt
    btn.disabled = false;
    btn.textContent = originalText;
  }
}

/* ───── 9.  FINAL QUIZ (stateful) ─────────────────────────────────────── */
function showFinalQuizModal() {
  topicSelectionList.innerHTML = libraryData
    .map(
      (t) =>
        `<label><input type="checkbox" name="final-quiz-topic" value="${t.id}"> ${t.title}</label>`
    )
    .join("");
  finalQuizModal.style.display = "flex";
}
function hideFinalQuizModal() {
  finalQuizModal.style.display = "none";
}
async function generateFinalQuiz() {
  const selected = Array.from($$('input[name="final-quiz-topic"]:checked')).map(
    (c) => c.value
  );
  const count = parseInt(questionCountInput.value, 10);
  if (!selected.length) return alert("Select at least one topic.");
  if (count < 5 || count > 20) return alert("Request 5-20 questions.");

  hideFinalQuizModal();
  views.finalQuiz.innerHTML = "<h2>Generating Final Quiz…</h2>";
  showView("finalQuiz");

  try {
    const data = await post("/generate_final_quiz", {
      user_id: currentUser.uid,
      topic_ids: selected,
      question_count: count,
    });
    currentAttemptId = data.attempt_id;
    currentFinalQuizQuestions = data.quiz_questions;
    renderFinalQuizView(currentFinalQuizQuestions);
  } catch (e) {
    views.finalQuiz.innerHTML = `<h2>Error</h2><p>${e.message}</p>`;
  }
}
function renderFinalQuizView(questions) {
  const shuffled = [...questions].sort(() => Math.random() - 0.5);
  const quizHtml = shuffled
    .map((q, i) => {
      const orig = questions.indexOf(q);
      const opts = normalizeOptions(q.options)
        .map(
          (o, j) =>
            `<label><input type="radio" name="${orig}" value="${j}" required><span>${o}</span></label>`
        )
        .join("");
      return `<div class="quiz-question"><h4>${i + 1}. ${
        q.question
      }</h4><div class="quiz-options">${opts}</div></div>`;
    })
    .join("");

  views.finalQuiz.innerHTML = `
    <h2>Cumulative Final Quiz</h2>
    <form id="final-quiz-form">${quizHtml}
      <button type="button" class="btn-primary" onclick="submitFinalQuiz()">Submit Final Quiz</button>
    </form>
    <button class="back-to-library" onclick="showView('library')" style="margin-top:1em;background:#6c757d">Cancel</button>`;
}
window.renderFinalQuizView = renderFinalQuizView;

async function submitFinalQuiz() {
  const ans = Object.fromEntries(new FormData($("#final-quiz-form")).entries());
  views.finalQuiz.innerHTML = "<h2>Scoring…</h2>";
  showView("finalQuiz");
  try {
    const data = await post("/submit_final_quiz", {
      user_id: currentUser.uid,
      attempt_id: currentAttemptId,
      user_answers: ans,
    });
    renderFinalQuizResults(data);
  } catch (e) {
    views.finalQuiz.innerHTML = `<h2>Error</h2><p>${e.message}</p>`;
  }
}
window.submitFinalQuiz = submitFinalQuiz;

function renderFinalQuizResults(data) {
  const { quiz_questions, user_answers, score, questions_total, title } = data;
  let html = `<h2>Final Quiz Results: ${title}</h2>
              <div class="results-summary"><h3>Your Score: ${score}/${questions_total}</h3></div>`;

  html += quiz_questions
    .map((q, i) => {
      const opts = normalizeOptions(q.options)
        .map((o, j) => {
          let cls = "option",
            icon = "⚪";
          if (j === q.correct_answer_index) {
            cls += " correct";
            icon = "✅";
          } else if (String(j) === user_answers[i]) {
            cls += " incorrect-selection";
            icon = "❌";
          }
          return `<div class="${cls}"><span class="icon">${icon}</span> ${o}</div>`;
        })
        .join("");
      return `<div class="results-question"><h4>${i + 1}. ${
        q.question
      }</h4><div class="results-options">${opts}</div><div class="explanation"><strong>Explanation:</strong> ${
        q.explanation
      }</div></div>`;
    })
    .join("");

  html += `<button class="back-to-library" onclick="showView('library')" style="margin-top:2em">← Back to Library</button>`;
  views.finalQuiz.innerHTML = html;
}
async function reviewFinalQuiz(attemptId) {
  views.finalQuiz.innerHTML = "<h2>Loading Past Results...</h2>";
  showView("finalQuiz");
  try {
    const data = await post("/get_final_quiz_attempt", {
      user_id: currentUser.uid,
      attempt_id: attemptId,
    });
    renderFinalQuizResults(data);
  } catch (e) {
    views.finalQuiz.innerHTML = `<h2>Error</h2><p>${e.message}</p>`;
  }
}
window.reviewFinalQuiz = reviewFinalQuiz;

/* Final-quiz modal wiring */
generateFinalQuizBtn.addEventListener("click", generateFinalQuiz);
cancelFinalQuizBtn.addEventListener("click", hideFinalQuizModal);
selectAllTopicsCheckbox.addEventListener("change", (e) => {
  $$('input[name="final-quiz-topic"]').forEach(
    (c) => (c.checked = e.target.checked)
  );
});

/* ───── 10.  CREATE-TOPIC WORKFLOW ────────────────────────────────────── */
$("#create-topic-btn").onclick = async () => {
  const title = prompt("Enter a custom topic title:");
  if (!title) return;

  const btn = $("#create-topic-btn");
  const originalText = btn.textContent;
  btn.disabled = true;
  btn.textContent = "Creating...";

  try {
    const data = await post("/create_custom_topic", {
      user_id: currentUser.uid,
      topic_title: title,
    });

    currentAttemptId = data.attempt_id;
    currentLessonId = data.lesson_id;
    currentLessonContext = data.content;

    libraryData.push({
      id: data.lesson_id,
      title: title,
      attempts: [], // It's a new topic, so it has no completed attempts yet.
    });

    renderLesson(data.content, data.lesson_id);
    showView("lesson");
  } catch (e) {
    alert(e.message);
    showView("library");
  } finally {
    btn.disabled = false;
    btn.textContent = originalText;
  }
};

/* ───── 11.  FLASHCARDS FROM LIBRARY (multi-topic) ────────────────────── */
function showFlashcardTopicModal() {
  flashcardTopicSelectionList.innerHTML = libraryData
    .map(
      (t) =>
        `<label><input type="checkbox" name="flashcard-topic" value="${t.id}"> ${t.title}</label>`
    )
    .join("");
  flashcardTopicModal.style.display = "flex";
}

function hideFlashcardTopicModal() {
  flashcardTopicModal.style.display = "none";
}

async function generateFlashcardsFromModal() {
  const selectedIds = Array.from(
    $$('input[name="flashcard-topic"]:checked')
  ).map((c) => c.value);
  if (!selectedIds.length) {
    return alert("Please select at least one topic.");
  }

  hideFlashcardTopicModal(); // Close the modal
  await genFlashcardsTopics(selectedIds); // Call the existing generation function
}

$("#library-flashcards-btn").onclick = showFlashcardTopicModal;
generateFlashcardsBtnModal.addEventListener(
  "click",
  generateFlashcardsFromModal
);
cancelFlashcardsBtnModal.addEventListener("click", hideFlashcardTopicModal);
selectAllFlashcardTopicsCheckbox.addEventListener("change", (e) => {
  $$('input[name="flashcard-topic"]').forEach(
    (c) => (c.checked = e.target.checked)
  );
});

/* ───── 12.  AI-TUTOR CHAT (unchanged) ────────────────────────────────── */
function toggleTutor() {
  const hidden =
    tutorChatContainer.style.display === "none" ||
    !tutorChatContainer.style.display;
  tutorChatContainer.style.display = hidden ? "flex" : "none";
}
window.toggleTutor = toggleTutor;

function addMessageToHistory(msg, type) {
  const m = el("div", `chat-message ${type}-message`, msg);
  tutorChatHistory.append(m);
  tutorChatHistory.scrollTop = tutorChatHistory.scrollHeight;
}
window.addMessageToHistory = addMessageToHistory;

async function sendTutorMessage() {
  const q = tutorInput.value.trim();
  if (!q || !currentLessonContext) return;
  addMessageToHistory(q, "user");
  tutorInput.value = "";
  addMessageToHistory("Typing…", "tutor");
  try {
    const { answer } = await post("/ask_tutor", {
      question: q,
      context: JSON.stringify(currentLessonContext),
    });
    tutorChatHistory.lastChild.remove(); // remove "Typing…"
    addMessageToHistory(answer, "tutor");
  } catch {
    tutorChatHistory.lastChild.remove();
    addMessageToHistory("Sorry, I had trouble connecting.", "tutor");
  }
}
window.sendTutorMessage = sendTutorMessage;
tutorInput.addEventListener("keydown", (e) => {
  if (e.key === "Enter" && !e.shiftKey) {
    e.preventDefault();
    sendTutorMessage();
  }
});

/* ───── 13.  AUTH CONTROLS ───────────────────────────────────────────── */
$("#login-btn").addEventListener("click", () =>
  signInWithPopup(auth, new GoogleAuthProvider())
);
$("#logout-btn").addEventListener("click", (e) => {
  e.preventDefault();
  signOut(auth);
});

onAuthStateChanged(auth, async (user) => {
  loginContainer.style.display = user ? "none" : "block";
  appContainer.style.display = user ? "block" : "none";
  if (user) {
    const { needs_onboarding } = await post("/create_user", {
      uid: user.uid,
      displayName: user.displayName,
      email: user.email,
    });
    if (needs_onboarding) {
      window.location.href = "/onboarding";
      return;
    }
    userNameSpan.textContent = user.displayName || "User";
    await initializeAppForUser(user);
  } else {
    currentUser = null;
    libraryData = [];
  }
});

/* ───── 14.  BOOTSTRAP (nothing else to do) ──────────────────────────── */
console.log("Paramigo front-end initialised.");


--- static/style.css ---
/* FILE: static/style.css
   Paramigo UI • Modern Refresh • June 24 2025
   ────────────────────────────────────────────
   ✱ Design language:
     • Soft neutral palette (indigo + slate grays)
     • Subtle shadows, 8 px radius, ample white-space
     • Utility button classes (.btn-primary / .btn-outline)
   ✱ Responsive mobile-first; desktop optimised at ≥768 px
   ✱ Includes legacy ID selectors so existing markup keeps working
*/

/* ─── CSS Variables / Palette ───────────────────────────────────────────── */
:root {
  --c-bg: #f5f7fa;
  --c-card: #ffffff;
  --c-border: #e0e4ea;
  --c-text: #1f2937;
  --c-muted: #6b7280;

  --c-primary: #3b82f6; /* indigo-blue */
  --c-primary-dark: #2563eb;
  --c-primary-light: #dbeafe;

  --c-success: #16a34a;
  --c-danger: #dc2626;
  --c-warning: #f59e0b;

  --radius: 8px;
  --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.06);
  --shadow-md: 0 4px 12px rgba(0, 0, 0, 0.08);
  font-size: 16px;
}

/* ─── Global Resets ─────────────────────────────────────────────────────── */
*,
*::before,
*::after {
  box-sizing: border-box;
}

body {
  margin: 0;
  font-family: system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
  background: var(--c-bg);
  color: var(--c-text);
  line-height: 1.55;
}

h1,
h2,
h3,
h4 {
  margin: 0.4em 0;
  line-height: 1.25;
}

a {
  color: var(--c-primary);
  text-decoration: none;
}

button,
input[type="number"],
input[type="checkbox"] {
  font-family: inherit;
}

/* ─── Utility Buttons ───────────────────────────────────────────────────── */
.btn-primary,
.btn-outline {
  padding: 10px 18px;
  font-size: 1rem;
  border-radius: var(--radius);
  border: 2px solid transparent;
  cursor: pointer;
  transition: background 0.15s, border-color 0.15s, transform 0.06s;
  user-select: none;
}

.btn-primary {
  background: var(--c-primary);
  color: #fff;
  border-color: var(--c-primary);
}
.btn-primary:hover {
  background: var(--c-primary-dark);
  border-color: var(--c-primary-dark);
}

.btn-outline {
  background: #fff;
  color: var(--c-primary);
  border-color: var(--c-primary);
}
.btn-outline:hover {
  background: var(--c-primary-light);
}

.btn-primary:active,
.btn-outline:active {
  transform: translateY(1px);
}

/* Legacy IDs to maintain behaviour */
#final-quiz-button {
  composes: btn-outline;
  width: 100%;
  padding: 14px;
  margin-top: 1rem;
}

/* ─── Layout Helpers ────────────────────────────────────────────────────── */
.page-container {
  width: 90%;
  max-width: 900px;
  margin: 2rem auto;
}

/* Library Controls */
.library-controls {
  display: flex;
  flex-wrap: wrap;
  gap: 0.75rem;
}

/* ─── Lesson Library View ──────────────────────────────────────────────── */
#lesson-library-view li {
  background: var(--c-card);
  margin: 0.5em 0;
  padding: 1em;
  border-radius: var(--radius);
  border: 1px solid var(--c-border);
  cursor: pointer;
  transition: box-shadow 0.2s;
}
#lesson-library-view li:hover {
  box-shadow: var(--shadow-sm);
}

.lesson-item-indicator {
  font-size: 0.8em;
  font-weight: bold;
  color: var(--c-success);
  margin-left: 10px;
}

/* Topic attempt history */
.attempt-item {
  background: #f9f9f9;
  border: 1px solid var(--c-border);
  padding: 1em;
  margin-bottom: 0.5em;
  border-radius: var(--radius);
  cursor: pointer;
}
.attempt-item:hover {
  background: #f1f1f1;
}

/* ─── Card-like Sections ───────────────────────────────────────────────── */
#lesson-taking-view,
#results-view,
#final-quiz-view {
  margin-top: 1em;
  padding: 1.5em;
  background: var(--c-card);
  border: 1px solid var(--c-border);
  border-radius: var(--radius);
  box-shadow: var(--shadow-sm);
}

/* ─── Quiz & Results ───────────────────────────────────────────────────── */
.quiz-question {
  margin-top: 1.75em;
  padding: 1em;
  border: 1px solid var(--c-border);
  border-radius: var(--radius);
  background: #f9f9f9;
}
.quiz-options label {
  display: block;
  margin: 0.5em 0;
  padding: 0.5em;
  border-radius: var(--radius);
  cursor: pointer;
  border: 2px solid transparent;
}
.quiz-options label:hover {
  background: var(--c-primary-light);
}
.quiz-options input[type="radio"]:checked + span {
  font-weight: bold;
}

.results-summary {
  padding: 1em;
  border-radius: var(--radius);
  background: #e9ecef;
  text-align: center;
  margin-bottom: 2em;
}
.results-question {
  margin-bottom: 1.5em;
  padding-bottom: 1.5em;
  border-bottom: 1px solid #eee;
}
.results-options .option {
  padding: 0.5em;
  border-radius: var(--radius);
  margin: 0.25em 0;
  display: flex;
  align-items: center;
}
.results-options .option.correct {
  background: #d1fae5;
  border-left: 5px solid var(--c-success);
}
.results-options .option.incorrect-selection {
  background: #fee2e2;
  border-left: 5px solid var(--c-danger);
}
.results-options .icon {
  margin-right: 0.5em;
  font-size: 1.2em;
}
.explanation {
  margin-top: 1em;
  padding: 1em;
  background: #f8f9fa;
  border-left: 3px solid var(--c-primary);
}

/* Smart Focus Prompt */
.smart-focus-prompt {
  padding: 1.5em;
  background: #fffbe6;
  border: 1px solid #ffe58f;
  border-radius: var(--radius);
  text-align: center;
  margin-top: 2em;
}
.smart-focus-prompt button {
  background: var(--c-warning);
  color: #212529;
}
.smart-focus-prompt button:hover {
  background: #e0a800;
}

/* ─── Back/Generic Buttons ─────────────────────────────────────────────── */
.back-to-library,
.delete-btn {
  margin-top: 2em;
}
.delete-btn {
  background: var(--c-danger);
}
.delete-btn:hover {
  background: #b91c1c;
}

/* ─── Accordions ───────────────────────────────────────────────────────── */
.accordion {
  margin-top: 1.25em;
}
.accordion-head {
  background: var(--c-primary);
  color: #fff;
  border: none;
  border-radius: var(--radius);
  padding: 0.6em 1em;
  width: 100%;
  text-align: left;
  cursor: pointer;
}
.accordion-body {
  background: #f1f5f9;
  border: 1px solid var(--c-border);
  border-radius: 0 0 var(--radius) var(--radius);
  padding: 1em;
  white-space: pre-wrap;
  font-size: 0.9rem;
}

/* ─── Final Quiz Modal (unchanged structurally) ────────────────────────── */
.modal-backdrop {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.5);
  z-index: 2000;
  display: none;
  justify-content: center;
  align-items: center;
}

.modal-content {
  background: var(--c-card);
  padding: 2em;
  border-radius: var(--radius);
  width: 90%;
  max-width: 600px;
  box-shadow: var(--shadow-md);

  /* --- NEW STYLES TO FIX SCROLLING --- */
  max-height: 85vh; /* 1. The modal can never be taller than 85% of the screen height */
  display: flex; /* 2. This enables modern layout control for the children */
  flex-direction: column; /* 3. This stacks the children (header, list, buttons) vertically */
}

/*
  ADD this entire NEW rule right after the
  .modal-content rule you just replaced.
*/
#topic-selection-list,
#flashcard-topic-selection-list {
  overflow-y: auto; /* 4. This makes ONLY the list itself scrollable if it's too long */
  flex-grow: 1; /* 5. This tells the list to expand to fill the available space */
  padding-right: 1em; /* 6. This adds a little space so the scrollbar doesn't hide text */
}

/* ─── Tutor Floating Chat ──────────────────────────────────────────────── */
#tutor-button {
  position: fixed;
  bottom: 20px;
  right: 20px;
  z-index: 1000;
  padding: 14px 22px;
  border-radius: 50px;
  box-shadow: var(--shadow-md);
  background: var(--c-primary);
  color: #fff;
  font-size: 1.1em;
  display: none;
}
#tutor-chat-container {
  position: fixed;
  bottom: 90px;
  right: 20px;
  width: 340px;
  max-height: 500px;
  background: var(--c-card);
  border-radius: var(--radius);
  box-shadow: var(--shadow-md);
  z-index: 999;
  display: none;
  flex-direction: column;
}
#tutor-chat-header {
  padding: 10px;
  background: var(--c-primary-dark);
  color: #fff;
  border-radius: var(--radius) var(--radius) 0 0;
  display: flex;
  justify-content: space-between;
  align-items: center;
}
#tutor-close-btn {
  background: none;
  border: none;
  color: #fff;
  font-size: 1.4em;
  cursor: pointer;
}
#tutor-chat-history {
  flex-grow: 1;
  padding: 10px;
  overflow-y: auto;
}
.chat-message {
  max-width: 85%;
  padding: 8px 12px;
  border-radius: 15px;
  margin-bottom: 10px;
  word-wrap: break-word;
}
.user-message {
  background: var(--c-primary);
  color: #fff;
  margin-left: auto;
  border-bottom-right-radius: 0;
}
.tutor-message {
  background: #e9ecef;
  color: var(--c-text);
  margin-right: auto;
  border-bottom-left-radius: 0;
}
#tutor-input-area {
  display: flex;
  padding: 10px;
  border-top: 1px solid var(--c-border);
}
#tutor-input {
  flex-grow: 1;
  border: 1px solid var(--c-border);
  border-radius: 20px;
  padding: 8px 12px;
}
#tutor-send-btn {
  margin-left: 10px;
  border-radius: 50%;
  width: 44px;
  height: 44px;
  background: var(--c-primary);
  color: #fff;
  border: none;
  font-size: 1.1em;
  cursor: pointer;
}

/* ─── Flashcard Modal / Deck ───────────────────────────────────────────── */
.modal-ov {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.65);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 3000;
}
.modal {
  background: var(--c-card);
  border-radius: var(--radius);
  padding: 2rem;
  width: 90%;
  max-width: 650px;
  max-height: 90vh;
  overflow-y: auto;
  box-shadow: var(--shadow-md);
  position: relative;
}
.modal .close {
  position: absolute;
  top: 8px;
  right: 12px;
  font-size: 1.5em;
  background: none;
  border: none;
  cursor: pointer;
}
.deck {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
  gap: 1rem;
  margin-top: 1rem;
}
.card {
  perspective: 800px;
  cursor: pointer;
}
.face {
  background: var(--c-card);
  border: 1px solid var(--c-border);
  border-radius: var(--radius);
  box-shadow: var(--shadow-sm);
  padding: 1.2rem;
  transition: transform 0.5s;
  backface-visibility: hidden;
  min-height: 140px;
  display: flex;
  align-items: center;
  justify-content: center;
  text-align: center;
}
.card .back {
  transform: rotateY(180deg);
}
.card.flip .front {
  transform: rotateY(180deg);
}
.card.flip .back {
  transform: rotateY(0);
}

/* Export buttons inside modal */
.export {
  margin-top: 1.5rem;
  display: flex;
  gap: 0.75rem;
  justify-content: flex-end;
}

/* ─── Media Queries ────────────────────────────────────────────────────── */
@media (min-width: 768px) {
  .page-container {
    width: 80%;
  }
  .library-controls {
    justify-content: flex-start;
  }
}

/* --- FIX for Jumbled Modal --- */
#topic-selection-list label,
#flashcard-topic-selection-list label {
  /* Targeting both modals for consistency */
  display: block;
  margin-bottom: 0.75em;
  padding: 0.25em;
  border-radius: 4px;
}

#topic-selection-list label:hover,
#flashcard-topic-selection-list label:hover {
  background-color: #f0f4f8;
}
/* END OF FILE */


--- templates/index.html ---
<!-- FILE: templates/index.html -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Paramigo</title>

    <!-- Global style sheet (modernised in the next step) -->
    <link
      rel="stylesheet"
      href="{{ url_for('static', filename='style.css') }}"
    />
  </head>

  <body>
    <!-- ───── 1. LOGIN GATE ─────────────────────────────────────────────── -->
    <div id="login-container" class="page-container">
      <h1>Welcome to Paramigo</h1>
      <p>Please sign in to continue.</p>
      <button id="login-btn">Sign in with Google</button>
    </div>

    <!-- ───── 2. MAIN APP SHELL ──────────────────────────────────────────── -->
    <div id="app-container" style="display: none">
      <!-- ===== [THIS HEADER SECTION IS UPDATED] ===== -->
      <header class="page-container" style="padding-bottom: 0">
        <p>
          Hello, <span id="user-name"></span>!
          <a href="#" id="logout-btn" style="margin-left: 1em">(Sign Out)</a>
        </p>
        <!-- The old "(Change Learning Style)" link was removed from the line above. -->
        <!-- The following block is new. -->
        <p style="font-size: 0.9em; color: #6b7280; margin-top: -0.5em">
          Your learning style is set to: <b id="current-learning-style">...</b>
          <a href="/onboarding" style="margin-left: 0.5em">(Change)</a>
        </p>
      </header>
      <!-- ============================================= -->

      <main id="lesson-library-view" class="page-container">
        <!-- Controls injected immediately for convenience -->
        <div class="library-controls" style="margin-bottom: 1em">
          <button id="create-topic-btn" class="btn-primary">
            + Create Topic
          </button>
          <button id="library-flashcards-btn" class="btn-outline">
            Generate Flashcards
          </button>
        </div>

        <!-- Topic list & history will be rendered by JS -->
        <div id="library-dynamic-area"></div>
      </main>

      <!-- Topic detail -->
      <main
        id="topic-detail-view"
        class="page-container"
        style="display: none"
      ></main>

      <!-- Active lesson -->
      <main
        id="lesson-taking-view"
        class="page-container"
        style="display: none"
      ></main>

      <!-- Results / review -->
      <main
        id="results-view"
        class="page-container"
        style="display: none"
      ></main>

      <!-- Final quiz workflow -->
      <main
        id="final-quiz-view"
        class="page-container"
        style="display: none"
      ></main>
    </div>

    <!-- ───── 3. FLOATING AI-TUTOR CHAT ──────────────────────────────────── -->
    <button id="tutor-button" style="display: none" onclick="toggleTutor()">
      Ask Tutor 💬
    </button>

    <div id="tutor-chat-container">
      <div id="tutor-chat-header">
        <span>AI Tutor</span>
        <button id="tutor-close-btn" onclick="toggleTutor()">×</button>
      </div>
      <div id="tutor-chat-history"></div>
      <div id="tutor-input-area">
        <input id="tutor-input" placeholder="Ask a question..." />
        <button id="tutor-send-btn" onclick="sendTutorMessage()">➤</button>
      </div>
    </div>

    <!-- ───── 4. FINAL-QUIZ TOPIC-PICKER MODAL ───────────────────────────── -->
    <div id="final-quiz-modal" class="modal-backdrop">
      <div class="modal-content">
        <h2>Create a Cumulative Quiz</h2>
        <p>
          Select the topics you want to include and the total number of
          questions for your quiz.
        </p>

        <div
          style="
            margin-bottom: 1em;
            border-bottom: 1px solid #eee;
            padding-bottom: 0.5em;
          "
        >
          <label>
            <input type="checkbox" id="select-all-topics-checkbox" />
            <strong>Select All / Deselect All</strong>
          </label>
        </div>

        <div id="topic-selection-list">
          <!-- Topic check-boxes injected by JS -->
        </div>

        <div>
          <label for="question-count-input">Number of Questions:</label>
          <input
            type="number"
            id="question-count-input"
            value="10"
            min="5"
            max="20"
            style="width: 60px"
          />
        </div>

        <div style="margin-top: 2em">
          <button id="generate-final-quiz-btn">Generate Quiz</button>
          <button id="cancel-final-quiz-btn" style="background-color: #6c757d">
            Cancel
          </button>
        </div>
      </div>
    </div>

    <!-- ───── 5. FLASHCARD TOPIC-PICKER MODAL ────────────────────────── -->
    <div id="flashcard-topic-modal" class="modal-backdrop">
      <div class="modal-content">
        <h2>Generate Flashcards</h2>
        <p>Select the topics you want to include in your flashcard deck.</p>

        <div
          style="
            margin-bottom: 1em;
            border-bottom: 1px solid #eee;
            padding-bottom: 0.5em;
          "
        >
          <label>
            <input type="checkbox" id="select-all-flashcard-topics-checkbox" />
            <strong>Select All / Deselect All</strong>
          </label>
        </div>

        <div id="flashcard-topic-selection-list">
          <!-- Topic check-boxes injected by JS -->
        </div>

        <div style="margin-top: 2em">
          <button id="generate-flashcards-btn-modal">
            Generate Flashcards
          </button>
          <button
            id="cancel-flashcards-btn-modal"
            style="background-color: #6c757d"
          >
            Cancel
          </button>
        </div>
      </div>
    </div>

    <!-- ───── 6. APP SCRIPTS ─────────────────────────────────────────────── -->
    <!-- All interactive logic now lives in static/js/main.js -->
    <script
      type="module"
      src="{{ url_for('static', filename='js/main.js') }}"
    ></script>
  </body>
</html>


--- templates/onboarding.html ---
<!-- FILE: templates/onboarding.html -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Your Learning Style</title>

    <!-- A single, clean style block -->
    <style>
      body {
        font-family: system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
        display: flex;
        justify-content: center;
        align-items: flex-start;
        min-height: 100vh;
        margin: 0;
        background-color: #f4f4f9;
        color: #333;
        padding: 2em 0;
      }
      .container {
        width: 90%;
        max-width: 800px;
        text-align: center;
        padding: 2em;
        background: #fff;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
      }
      h1 {
        color: #0056b3;
      }
      .style-options {
        display: flex;
        flex-wrap: wrap;
        gap: 1em;
        margin-top: 2em;
        text-align: left;
      }
      .style-box {
        flex: 1;
        min-width: 200px;
        padding: 1.5em;
        border: 2px solid #ddd;
        border-radius: 8px;
        cursor: pointer;
        transition: border-color 0.2s, box-shadow 0.2s;
        display: flex;
        flex-direction: column;
      }
      .style-box:hover {
        border-color: #007bff;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }
      .style-box h3 {
        margin-top: 0;
        color: #007bff;
      }
      .style-box p {
        flex-grow: 1;
      }
      .custom-option {
        margin-top: 2.5em;
        text-align: left;
      }
      textarea {
        width: 100%;
        padding: 0.75em;
        border-radius: 5px;
        border: 1px solid #ccc;
        min-height: 80px;
        box-sizing: border-box;
        font-size: 1rem;
        line-height: 1.5;
      }
      .main-actions {
        margin-top: 1.5em;
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-wrap: wrap;
        gap: 1em;
      }
      button {
        background-color: #007bff;
        color: white;
        padding: 12px 20px;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-size: 1rem;
        transition: background-color 0.2s;
      }
      button:hover {
        background-color: #0056b3;
      }
      button:disabled {
        background-color: #aaa;
        cursor: not-allowed;
      }
      a.back-link {
        color: #6c757d;
        text-decoration: none;
      }
    </style>
  </head>

  <body>
    <!-- A single, clean body structure -->
    <div class="container">
      <h1>Update Your Learning Style</h1>
      <p>
        Your current learning style is shown in the text box below. You can edit
        it directly, or click one of the presets to use it as a starting point.
      </p>

      <!-- The style boxes now act as buttons to populate the text area -->
      <div class="style-options">
        {% for style in styles %}
        <div class="style-box" onclick="selectPreset('{{ style.style_name }}')">
          <h3>{{ style.style_name }}</h3>
          <p>{{ style.explanation }}</p>
        </div>
        {% endfor %}
      </div>

      <!-- This is now the main editor for the learning style -->
      <div class="custom-option">
        <label for="custom-style-input"
          ><strong>Your Learning Style:</strong></label
        >
        <textarea
          id="custom-style-input"
          placeholder="Loading your style..."
        ></textarea>
      </div>

      <!-- A single, clear action bar -->
      <div class="main-actions">
        <a href="/" class="back-link">← Go Back Without Saving</a>
        <button onclick="saveAndExit()">Save & Return to App</button>
      </div>
    </div>

    <!-- A single, consolidated script block -->
    <script type="module">
      // Import Firebase tools
      import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js";
      import {
        getAuth,
        onAuthStateChanged,
      } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-auth.js";

      // Same Firebase config as your main page
      const firebaseConfig = {
        apiKey: "AIzaSyB4EJ5fu2ZGn3YG6NerCZRHfLj3F1mvpww",
        authDomain: "paramigo-tool-03.firebaseapp.com",
        projectId: "paramigo-tool-03",
        storageBucket: "paramigo-tool-03.firebasestorage.app",
        messagingSenderId: "626376082375",
        appId: "1:626376082375:web:7b0edfa3319c258d900fe2",
        measurementId: "G-5C44175E71",
      };

      const app = initializeApp(firebaseConfig);
      const auth = getAuth(app);

      let currentUser = null;
      const customStyleInput = document.getElementById("custom-style-input");
      const saveButton = document.querySelector(".main-actions button");

      // Fetches the user's current style and populates the text box
      async function loadCurrentUserStyle() {
        if (!currentUser) return;

        try {
          const response = await fetch("/get_user_profile", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ user_id: currentUser.uid }),
          });
          if (!response.ok) throw new Error("Failed to fetch profile");

          const profile = await response.json();
          const currentStyle = profile.learningStyle || "";
          customStyleInput.value = currentStyle;
        } catch (error) {
          console.error("Error loading user style:", error);
          customStyleInput.value =
            "Could not load your style. Please enter it here.";
        }
      }

      // Runs when a user clicks one of the three preset boxes
      window.selectPreset = function (styleName) {
        customStyleInput.value = styleName;
      };

      // The one and only save function for this page
      window.saveAndExit = async function () {
        if (!currentUser) {
          alert("Error: Not signed in.");
          return;
        }

        const newStyle = customStyleInput.value.trim();
        if (!newStyle) {
          alert("Please enter a description of your preferred style.");
          return;
        }

        // Disable button to prevent double-clicks
        saveButton.disabled = true;
        saveButton.textContent = "Saving...";

        try {
          await fetch("/save_preference", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              uid: currentUser.uid,
              style: newStyle,
            }),
          });
          // After saving, send them to the main app page
          window.location.href = "/";
        } catch (error) {
          alert(`Error saving your style: ${error.message}`);
          // Re-enable button on failure
          saveButton.disabled = false;
          saveButton.textContent = "Save & Return to App";
        }
      };

      // When the page loads, check for auth status and then load the user's style
      onAuthStateChanged(auth, (user) => {
        if (user) {
          currentUser = user;
          loadCurrentUserStyle();
        } else {
          // If for some reason they land here without being logged in, send them home.
          window.location.href = "/";
        }
      });
    </script>
  </body>
</html>
